## 生产者消费者问题  
### 问题描述  
一组生产者进程和一组消费者进程共享一个初始为空的、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中去除消息，否则必须等待。且由于缓冲区是临界资源，在同一时刻，仅允许一个生产者或一个消费者进入。  
### 问题分析  
1. 关系分析  
由于不允许同时访问缓冲区这一临界资源，所以生产者和消费者对缓冲区的访问是互斥的。又因为生产者放入消息到缓冲区，消费者从缓冲区取出消息，所以两者也为同步关系。  
2. 整理思路  
对于生产者和消费者进程来说，存在同步互斥的关系。因此需要解决这两种关系。  
3. 信号量设置  
+ 互斥：为了互斥使用缓冲区这一临界资源，设置一个互斥信号量`mutex=1`用于解决两个进程的互斥访问问题。  
+ 同步，设置`full=0;empty=n`  
  - 对于生产者，生产的时候P空缓冲区，V满缓冲区  
  - 对于消费者，消费的时候P满缓冲区，V空缓冲区
4. 代码描述  
```伪C
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
producer()
{
    while(1)
    {
        produce an item in nextp;
        P(empty);
        P(mutex);
        add nextp to buffer;
        V(mutex);
        V(full);
    }
}
consumer()
{
    while(1)
    {
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
        consumer the item;
    }
}
```
5. 代码分析  
在生产者和消费者进程中
```
P(empty);
P(mutex);
```
和
```
P(full)；
P(mutex);
```
的顺序不能颠倒为
```
P(mutex);
P(empty);
```
和
```
P(mutex);
P(full)；
```
考虑一种情况：生产者已将缓冲区生产满，即此时(full = n)&&(empty =0)，且此时要继续执行生产者进程，先正常执行`P(mutex);`，然后再执行`P(empty);`，此时由于empty<0，生产者进程阻塞，进程调度至消费者进程，执行`P(mutex);`时，程序即被阻塞。在这种情况下，生产者永远等不到消费者消费的时候，便陷入了无休止的等待。  

## 生产者消费者问题二  
### 问题描述  
桌上有一个盘子，每次只能向其中放入一个水果。爸爸专门向盘子中放入苹果，妈妈专门向盘子中放入橘子，儿子专等盘子中的橘子吃，女儿专等盘子中的苹果吃。只有盘子为空时，才允许放入水果，只有盘子中放有对应要吃的水果时，才允许去吃。 
### 问题分析  
1. 关系分析  
由每次只能向其中放入一个水果可知，爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，**而且这两对进程必须连续执行**。**儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发**。  
2. 整理思路  
可抽象为两对生产者-消费者连接到大小为1的缓冲区上。但不同的是，只需要考虑两对生产者-消费者之间互斥使用缓冲区，两个消费者与自己各自的生产者为同步关系，且生产的内容不同。  
3. 信号量设置  
+ 互斥，设置互斥量`plate=1`用于两对进程互斥访问盘子  
+ 同步，分别设置`apple=0`和`orange=0`用于生产-消费同步  
+ 特殊设置，为了保证生产-消费的连续性，在生产者中`P(plate)`，而在消费者当中`V(plate)`。此外，由于两位消费者仅能消费特定的内容，所以即使消费者进行了切换，也由于不满足条件，会被阻塞。  
4. 代码描述  
```伪C
semaphore plate = 1;
semaphore apple = 0;
semaphore orange = 0;
dad()
{
    prepare an apple;
    P(plate);
    put an apple on the plate;
    V(apple);
}
mom()
{
    prepare an orange;
    P(plate);
    put an orange on the plate;
    V(orange);
}
son()
{
    P(orange);
    take the orange from the plate;
    V(plate);
    eat the orange;
}
daughter()
{
    P(apple);
    take the apple from the plate;
    V(plate);
    eat the apple;
}
```  
## 读者写者问题
### 问题描述  
有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据不会产生副作用，但若某个写进程和其他进程（读或写进程）同时访问数据时则可能导致数据不一致的错误。因此要求：  
+ 允许多个读者可以同时对文件执行读操作
+ 一次只允许一个写者往文件中写信息
+ 任意写者在完成操作之前不允许其他读写者访问数据
+ 写者执行写操作前，应让已有的读者和写者全部退出  
### 问题分析  
1. 关系分析  
读者与写者互斥，读者与读者不互斥；写者与其余读写者都互斥。  
2. 整理思路  
+ 写者：直接使用互斥信号量即可保证写者之间互斥
+ 读者与写者的互斥：只要有读者在读，写者就应该被阻塞，而**为了记录此时有多少读者在读，设置一个计数器。同时，为了保护读者对于计数器的修改，应设置一个互斥信号量保证计数器增减的原子性**
3. 信号量设置  
+ 互斥  
  - 写者间互斥`rw=1`
  - 计数器互斥`mutex=1`
+ 计数器  
  - 计数器`count=0`  
4. 代码描述
```伪C
int count = 0；
semaphore mutex = 1;
semaphore rw = 1;
writer()
{
    while(1)
    {
        P(rw);
        writing;
        V(rw);
    }
}
reader()
{
    while(1)
    {
        // when reader in
        P(mutex);
        if(count == 0)
            P(rw); // prevent writer from writing
        count++;
        V(mutex);
        reading;
        // when reader out
        count--;
        P(mutex);
        if(count == 0)
            V(rw); // allow writer to writing
        V(mutex);
    }
}
```