## 图的应用  
### 最小生成树  
一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。  
对于一个带权连通无向图G = (V, E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设𝕽为G的所有生成树的集合，若T为𝕽中边的权值之和最小的那棵生成树，则T称为G的最小生成树(Minimum-Spanning Tree,MST)。  
最小生成树具有如下性质：  
+ 最小生成树不是唯一的，即最小二叉树的树形不唯一，𝕽中可能有多个最小生成树。当图G中的各边权值互不相等时，G的最小生成树是唯一的；若无向连通图G的边数比顶点树少1，即G本身是一棵树时，则G的最小生成树就是它本身。  
+ 最小生成树的边的权值之和总是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和是唯一的，而且是最小的。  
+ 最小生成树的边数为顶点数减1  

构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质；假设G = (V, E)是一个带权连通无向图，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值的边，其中u∊U，v∊V-U，则必存在一棵包含边(u, v)的最小生成树。  
基于该性质的最小生成树算法主要有Prim算法和kruskal算法，它们都基于贪心算法的策略。  
通用最小生成树算法：  
```C
GENERIC_MST(G)
{
    T = NULL;
    while T 未形成一棵生成树
        do 找到一条最小代价边(u, v)并且加入T后不会产生回路
            T = T ⋃ (u, v);
}
```
#### Prim算法  
Prim算法构造最小生成树的过程：初始时从图中任取一顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入T，得到的就是最小生成树。此时T中必然有n-1条边。  
Prim算法的步骤如下：  
假设G = (V, E)是连通图，其最小生成树T = (U, E<sub>T</sub>)，E<sub>T</sub>是最小生成树中边的集合。  
+ 初始化：向空树T = (U, E<sub>T</sub>)中添加图G = (V, E)的任一顶点u<sub>0</sub>，使U = {u<sub>0</sub>}，E<sub>T</sub> = ∅。  
+ 循环（重复下列操作直至U == V）：从图中选择满足{(u, v)|u∊U，v∊V-U}切具有最小权值的边(u, v)，加入树T，置U = U ⋃ {v}，E<sub>T</sub> = E<sub>T</sub> ⋃ {(u, v)}。  

Prim算法的简单实现如下：  
```C
void Prim(G, T)
{
    T = ∅;// 初始化空树
    U = {w};// 添加任一顶点w
    while((V - U) != ∅)// 树中不含所有结点
    {
        设(u, v)是使u∊U，v∊V-U，且权值最小的边
        T = T ⋃ {(u, v)};
        U = U ⋃ {v};
    }
}
```  
Prim算法的时间复杂度为O(|V|<sup>2</sup>)，不依赖于|E|，因此它适用于求解边稠密的图的最小生成树。  

#### Kruskal算法  
与Prim算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合适的边构造生成树的方法。  
Kruskal算法构造最小生成树的过程：初始时只有n个顶点而无边的非连通图T = {V, {}}，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在不同的连通分量上，则将此边加入T，否则舍弃此边而选择下一条权值最小的边。以此类推，直至T中所有丁点都在同一个连通分量上。  
Kruskal算法的步骤如下：  
假设G = (V, E)是连通图，其最小生成树T = (U, E<sub>T</sub>)。  
+ 初始化：U = V，E<sub>T</sub> = ∅。即每个顶点构成一棵独立的树，T此时是一个仅含|V|个顶点的森林。  
+ 循环（重复下列操作直至T是一棵树）：按G的边的权值递增顺序依次从E - E<sub>T</sub>中选择一条边，若这条边加入T后不构成回路，则将其加入E<sub>T</sub>，否则舍弃，直到E<sub>T</sub>中含有n-1条边。  

Kruskal算法的简单实现如下：  
```C
void Kruskal(V, T)
{
    T = V; // 初始化树T，仅含顶点
    numS = n;// 连通分量数
    while(numS > 1)
    {
        从E中取出权值最小的边(v, u);
        if(v和u属于T中不同的连通分量)
        {
            T = T ⋃ {(v, u)};
            numS--;
        }
    }
}
```  
根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。  
通常在Kruskal算法中，采用堆来存放边的集合，因此每次选择权值最小的边只需要O(log|E|)的时间。此外，由于生成树T中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为O(|E|log|E|)。因此，Kruskal算法适合于边稀疏而顶点较多的图。  

### 最短路径  
广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点v<sub>i</sub>到图中其余任意一个顶点v<sub>j</sub>的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。  
求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra算法求解；二是求每对顶点间的最短路径，可通过Floyd算法来求解。  
