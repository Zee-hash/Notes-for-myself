# 树和森林  
---  
## 树的存储结构  
树的存储方式有很多种，既可以采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系。  
### 双亲表示法  
> 这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。根结点下标为0，其伪指针域为-1。  

双亲表示法的存储结构描述如下：  
```C
#define MAX_TREE_SIZE 100;//  树中最多结点数
typedef struct// 树中结点定义
{
    ElemType data;// 数据元素
    int parent;// 双亲位置域
}PTNode;
typedef struct// 双亲表示树的定义
{
    PTNode nodes[MAX_TREE_SIZE];
    int n;// 节点数
}PTree;
```  
该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。  
在树的存储结构中，数组下标表示结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。  

### 孩子表示法  
> 孩子表示法是将每个结点的孩子结点都用单链表链接起来形成的一个线性结构，此时n个结点就有n个孩子链表（叶子结点的孩子链表为空表）。  

这种存储方式寻找子女的操作非常直接，而寻找双亲的操作则需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。  

### 孩子兄弟法  
> 孩子兄弟法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使得每个结点包括三部分内容：结点值、指向第一个孩子结点的指针、指向下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。  

孩子兄弟表示法的存储结构描述如下：  
```C
typedef struct CSNode
{
    ElemTyep data;// 数据域
    struct CSNode *firstChild, *nextSibling;// 第一个孩子和右兄弟
}CSNode, *CSTree;
```  
这种存储表示法比较灵活，其最大优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点时比较麻烦。若为每个结点增设一个parent域指向其父节点，则查找结点的父结点也很方便。  

---  
## 树、森林与二叉树的转换  
> 由于二叉树和树都可以用二叉链表作为存储结构，因此对于同一存储结构作不同的解读即产生了不同的逻辑结构。  

以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树，可以找到唯一的一棵二叉树与之对应。  
树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。  
树转换为二叉树的画法：  
+ 在兄弟结点之间加一条线  
+ 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉  
+ 以树根为轴心，顺时针旋转45°  

森林转换成二叉树的画法：  
+ 将森林中的每棵树转换成相应的二叉树  
+ 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线  
+ 以第一棵树的根为轴心顺时针旋转45°  

二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左孩子为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树可视为一个除第一棵树外的森林转换后的二叉树，应用相同的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。二叉树转换为树或森林是唯一的。  

---  
## 树和森林的遍历  
> 树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。  

主要有两种遍历方式：  
+ 先根遍历。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。  
+ 后根遍历。若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。  

树也有层次遍历，与二叉树的层次遍历的思想基本相同，即按层序依次访问各结点。  
按照森林和树的相互递归的定义，可得到森林的两种遍历方法：  
+ 先序遍历森林。如森林为非空，则按如下规则进行遍历：  
  - 访问森林中第一棵树的根结点  
  - 先序遍历第一棵树中的根结点的子树森林  
  - 先序遍历除去第一棵树之后剩余的树构成的森林  

+ 中序遍历森林。森林为非空时，则按如下规则进行遍历：  
  - 中序遍历森林中第一棵树的根结点的子树森林  
  - 访问第一棵树的根结点  
  - 中序遍历除去第一棵树之后剩余的树构成的森林  

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为其对应二叉树的先序和中序遍历。  
树和森林的遍历与二叉树遍历的对应关系：  

|树|森林|二叉树|  
|---|---|---|  
|先根遍历|先序遍历|先序遍历|  
|后根遍历|中序遍历|中序遍历|  

---  
## 树的应用——并查集  
并查集是一种简单的集合表示，它支持以下三种操作：  
```C
Union(S, Root1, Root2);// 把集合S中子集合Root2并入Root1。要求Root1和Root2互不相交，否则不执行合并
Find(S, x);// 查找集合S中单元素x所在的子集合，并返回该子集合的名字
Initial(S);// 将集合S中的每个元素初始化为只有一个单元素的子集合
```
通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数。  
为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结点。  
在采用树的双亲指针数组作为并查集的存储表示时，集合元素的编号从0到size-1。其中，size是最大元素的个数。下面是并查集主要运算的实现。  
并查集的结构定义如下：  
```C
#define SIZE 100
int UFSets[SIZE];// 集合元素数组（双亲指针数组）
```  
并查集的初始化操作（S即为并查集）：  
```C
void Initial(int S[])
{
    for(int i = 0; i < size; i++)
    {
        S[i] = -1;// 每个自成单元素集合
    }
}
```  
Find操作（函数在并查集S中查找并返回包含元素x的树的根）：  
```C
int Find(int S[], int x)
{
    while(S[x] >= 0)
    {
        x = S[x];// 循环寻找x的根
    }
    return x;
}
```  
Union操作（函数求两个不相交子集合的并集）：  
```C
void Union(int S[], int Root1, int Root2)
{
    S[Root2] = Root1;// 将根Root2连接到另一根Root1下面
}
```