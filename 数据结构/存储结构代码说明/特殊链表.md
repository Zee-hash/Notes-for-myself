# 线性表  
## 双链表  
> 单链表结点中一个指向其后继的指针，使得单链表只能从头开始依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除时），只能从头开始便利，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。  

为了克服单链表的缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点。  
双链表中结点类型的描述如下：  
```C
typedef struct DNode
{
    ElemType data;// 数据域
    struct DNode *prior, *next;// 前驱和后继指针
}DNode, *DLinkList;
```  
双链表可以很方便地找到其前驱结点，因此，插入、删除操作的时间复杂度为O(1)。  
### 双链表的插入操作  
> 在双链表中p所指的结点之后插入结点*s  

```C
s->next = p->next;
s->next->prior = s;
s->prior = p;
p->next = s;// 保证这一步在第一二步之前，避免p->next信息丢失  
```
### 双链表的删除操作  
> 删除双链表中结点*p的后继结点*q  

```C
p->next = q->next;
q->next->prior = p;
free(q);// 释放结点空间
```  

## 循环链表  
### 循环单链表
> 循环单链表和单链表的区别在于，表中的最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。  

在循环单链表中，表尾结点*r的next指针域指向L，故表中没有指针域为NULL的结点，因此，循环单链表判空条件是`L->next==L`，即头结点的指针是否等于头结点。  
循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表保持循环的性质。当然，正是因为循环链表是一个“环”，因此在任何一个位置上的插入和删除操作都是等价的，无须判断是否为表尾。  
在单链表中只能从表头结点开始往后遍历整个链表，而循环链表可以从表中的任何一个结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而设尾指针，从而使得操作效率更高。其原因是，若设的是头指针，对表尾进行操作需要O(n)的时间复杂度，而若设的是尾指针，r->next即为头指针，对于表头和表尾进行操作都只需要O(1)的时间复杂度。  
### 循环双链表  
> 由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点。  

在循环双链表中，某结点*p为尾结点时，`p->next==L`；当循环链表为空表时，`(L->next==L)&&(L->prior==L)`。  

## 静态链表  
> 静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面所讲的链表的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。  

```C
#define MaxSize 50 // 静态链表的最大长度
typedef struct
{
    ElemType data;// 存储数组元素
    int next;// 下一个元素的数组下标
}SLinkList[MaxSize];
```
静态链表以`next==-1`作为其结束的标志。静态链表的插入、删除操作与动态链表相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言中，这是一种非常巧妙的方法。  
