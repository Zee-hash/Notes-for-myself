# 树和二叉树的应用  
---  
## 二叉排序树BST  
### 二叉排序树的定义  
二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：  
+ 若左子树非空，则左子树上所有结点的值均小于根结点的值  
+ 若右子树非空，则右子树上所有结点的值均大于根结点的值  
+ 左、右子树也分别是一棵排序二叉树  

根据二叉排序树的定义，左子树结点值<根结点值<右子树结点值，所以对二叉树进行中序遍历，可以得到一个递增的有序序列。  
### 二叉排序树的查找  
二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。  
二叉排序树的非递归查找算法：  
```C
BSTree *BST_Search(BiTree T, ElemType key)
{
    while(T != NULL && key != T->data)// 若树空或等于根结点值，则结束循环
    {
        if(key < T->data)
        {
            T = T -> lchild;// 从左子树上继续查找
        }
        else
        {
            T = T -> rchild;// 从右子树上继续查找
        }
    }
    return T;
}
```  
### 二叉排序树的插入  
二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点再进行插入的。  
插入结点的过程如下：若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树，插入的结点一定是个新添加的叶节点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。  
二叉排序树插入操作的算法描述如下：  
```C
int BST_Insert(BiTree &T, KeyType k)
{
    if(T == NULL)// 原树为空，新插入的记录为根结点
    {
        T = (BiTree)malloc(sizeof(BSTNode));
        T -> key = k;
        T -> lchild = NULL;
        T -> rchild = NULL;
        return 1;// 插入成功
    }
    else if(k == T -> key)// 树中存在相同关键字的结点，插入失败
    {
        return 0;
    }
    else if(k < T -> key)// 插入到T的左子树
    {
        return BST_Insert(T->lchild, k);
    }
    else// 插入到T的右子树
    {
        return BST_Insert(T->rchild, k);
    }
}
```  
### 二叉树的构造  
从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。  
构造二叉排序树的算法描述如下：  
```C
void Create_BST(BiTree &T, KeyType str[], int n)
{
    T = NULL;
    int i = 0;
    while(i < n)// 依次将每个关键字插入到二叉排序树中
    {
        BST_Insert(T, str[i]);
        i++;
    }
}
```  
### 二叉排序树的删除  
从二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：  
+ 若被删除的结点z是叶结点，则直接删除，不会破坏二叉排序树的性质  
+ 若结点z只有一棵左子树或右子树，则让z的子树称为z父结点的子树，替代z的位置。  
+ 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删除这个直接后继（或直接前驱），这样就转换成了第一种或第二种情况。  

### 二叉排序树的查找效率分析  
二叉排序树的查找效率，主要取决于树的高度。若二叉排序树的左、右子树的高度之差的绝对值不超过1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为O(log<sub>2</sub>n)。若二叉排序树是一个只有右（左）孩子的单支树，则其平均查找长度为O(n)。  
在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变差，树的高度也增加为元素个数n。  
从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树。  
就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，平均维护时间为O(log<sub>2</sub>n)。二分查找的对象是有序表，若有插入和删除结点的操作，所花的代价是O(n)。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表时，则应选择二叉排序树作为其逻辑结构。  

---  
## 平衡二叉树  
### 平衡二叉树的定义  
为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树，简称平衡树。定义结点左子树和右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只能是-1，0，1。  
因此，平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：  
+ 左子树和右子树都是平衡二叉树  
+ 左子树和右子树的高度差的绝对值不超过1  

### 平衡二叉树的插入  
二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到**插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A**，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。