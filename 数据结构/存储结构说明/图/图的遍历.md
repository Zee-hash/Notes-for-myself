## 图的遍历  
图的遍历是指从图中的某一顶点除法，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。**图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础**。  
图的遍历比树的遍历要复杂得多，因为图的任一顶点都可能与其他的顶点相邻，所以在访问某个顶点后，可能沿着某条搜索路径搜索又回到该顶点上。为避免同一顶点被被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组visited[]来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。  
### 广度优先搜索  
广度优先搜索Breadth-First-Search类似于二叉树的层序遍历算法。基本思想是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接结点w<sub>1</sub>，w<sub>2</sub>，···，w<sub>i</sub>，然后依次访问w<sub>1</sub>，w<sub>2</sub>，···，w<sub>i</sub>的所有未被访问过的邻接结点；在从这些访问过的结点出发，访问它们所有为被访问过的邻接结点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问过的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。  
换句话说，广度优先搜索遍历图的过程是以v为起始点，由进至远依次访问和v有路径相通且路径长度为1,2,···的顶点。广度优先搜索是一种分层查找过程，每向前走一步可能访问一批顶点。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。  
广度优先搜索算法的伪代码如下：  
```C
bool visited[MAX_VERTEX_NUM];// 访问标记数组
void BFSTraverse(Graph G)
{
    for(i = 0; i < G.vexnum; ++i)
    {
        visited[i] = false;// 访问标记数组初始化
    }
    InitQueue(Q);// 初始化辅助队列
    for(i = 0; i < G.vexnum; ++i)
    {
        if(!visited[i])
        {
            BFS(G, i);// 未被访问过，开始BFS
        }
    }
}
void BFS(Graph G, int v)
{
    visit(v);// 访问起始顶点v
    visited[v] = true;// 对v已访问标记
    Enqueue(Q, v);// 顶点v入队列Q
    while(!QueueEmpty(Q))
    {
        DeQueue(Q, v);// 顶点v出队列
        for(w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
        {
            if(!visited[w])// w为v尚未被访问的邻接顶点
            {
                visit[w];
                visited[w] = true;
                EnQueue(Q, w);// 顶点w入队列
            }
        }
    }
}
```  
辅助数组visited[]标志顶点是否被访问过，其初始状态为`false`。在图的遍历过程中，一旦某个顶点v<sub>i</sub>被访问，就立即置visited[i]为`true`，防止它多次被访问。  
#### BFS算法的性能分析  
无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均需入队一次，在最坏的情况下，空间复杂度为O(|V|)。  
采用邻接表存储方式时，每个顶点均需搜索一次（或入队一次），故时间复杂度为O(|V|)，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(|E|)，算法总的时间复杂度为O(|V|+|E|)。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为O(|V|)，故算法总的时间复杂度为O(|V|<sup>2</sup>)。  
#### BFS算法求解单源最短路径问题  
若图G = (V, E)为非带权图，定义从顶点u到顶点v的最短路径d(u, v)为从u到v的任何路径中最少的边数；若从u到v没有通路，则d(u, v)=∞。  
使用BFS求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先算法总是按照距离由近到远来遍历图中每个顶点的性质决定的。  
BFS算法求解单源最短路径问题的算法如下：  
```C
void BFS_MIN_Distance(Graph G, int u)
{
    for(i = 0; i < G.vexnum; ++i)
    {
        d[i] = ∞;// 初始化路径长度  
    }
    visited[u] = true;
    d[u] = 0;
    Enqueue(Q, u);
    while(!QueueEmpty(Q))
    {
        DeQueue(Q, u);
        for(w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u, w))
        {
            if(!visited[w])
            {
                visited[w] = true;
                d[w] = d[u] + 1；
                EnQueue(Q, w);
            }
        }
    }
}
```  

#### 广度优先生成树  
在广度遍历的过程中，可以得到一棵遍历树，称为广度优先生成树。需要注意的是，一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于其邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。  

### 深度优先搜索  
与广度优先搜索不同，深度优先搜索Depth-First-Search,DFS类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。  
它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w<sub>1</sub>，再访问与w<sub>1</sub>邻接且未被访问的任一顶点w<sub>2</sub>······重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点为被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。  
其递归形式算法过程如下：  
```C
bool visited[MAX_VERTEX_NUM]; // 访问标记数组
void DFSTraverse(Graph G)
{
    for(v = 0, v < G.vexnum; ++v)
    {
        visited[v] = false;// 初始化已访问标记数组
    }
    for(v = 0; v < G.vexnum; ++v)
    {
        if(!visited[v])
        {
            DFS(G, v);
        }
    }
}
void DFS(Graph, int v)// 从顶点v出发，深度优先遍历图G
{
    visit(v);// 访问顶点v
    visited[v] = true;// 设已访问标志
    for(w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
    {
        if(!visited[w])
        {
            DFS(G, w);
        }
    }
}
```  
图的邻接矩阵表示是唯一的，但对于每个邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。  
#### DFS算法的性能分析  
DSF算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为O(|V|)。  
遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所用的存储结构。以邻接矩阵表示时，查找每个顶点的邻接表所需的时间为O(|V|)，故总的时间复杂度为O(|V|<sup>2</sup>)。以邻接表表示时，查找所有顶点的邻接表所需的时间为O(|E|)，访问顶点所需的时间为O(|V|)，此时，总的时间复杂度为O(|V|+|E|)。  
#### 深度优先的生成树和生成森林  
与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。  

### 图的遍历与图的连通性  
图的遍历算法可以用来判断图的连通性。  
对于无向图来说，若无向图是连通的，则从任一顶点出发，仅需一次遍历就能访问图中的所有顶点；若无向图是非连通的，则从某一顶点出发，一次遍历只能访问到该顶点所在连通分量所有顶点，而对于图中其他连通分量的顶点，则无法通过此次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，负责不能访问到所有顶点。  
故在BFSTraverse()和DFSTraverse()中的  
```C
for(i = 0; i < G.vexnum; ++i)
{
    if(!visited[i])
    {
            // BFS(G, i)或DFS(G, i)
    }
}
```
部分就是为了再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。  
对于无向图，上述循环中调用BFS(G, i)或DFS(G, i)的次数等于该图的连通分量数。  
对于有向图，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS(G, i)或DFS(G, i)无法访问到该连通分量的所有顶点。（如当前遍历起始点为弧尾指向的顶点时）。  