## 图的存储及基本操作  
图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于欲求解的问题。  
### 邻接矩阵法  
所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。  
结点数为n的图G = (V, E)的邻接矩阵**A**是n×n的。将G的顶点编号为v<sub>1</sub>，v<sub>2</sub>，···，v<sub>n</sub>。若(v<sub>i</sub>,v<sub>j</sub>) ∈ E，则A[i][j] = 1，否则A[i][j] = 0。  
对于带权图而言，若顶点v<sub>i</sub>和v<sub>j</sub>之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点v<sub>i</sub>和v<sub>j</sub>不相连，则用∞来代表这两个顶点之间不存在边。  
图的邻接矩阵存储结构定义如下：  
```C
#define MaxVertexNum 100// 顶点数目的最大值
typedef char VertexType;// 顶点的数据类型
typedef int EdgeType;// 带权图中边上权值的数据类型
typedef struct
{
    VertexType Vex[MaxVertexNum];// 顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];// 邻接矩阵
    int vexnum, arcnum;// 图的当前顶点数和弧数
}MGraph;
```
Notes:  
+ 在简单应用中，可直接用二维数组作为图的邻接矩阵，即顶点信息等均可忽略。  
+ 当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。  
+ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。  
+ 邻接矩阵表示法的空间复杂度为O(n<sup>2</sup>)，其中n为图的顶点数|V|。  

图的邻接矩阵存储表示法具有以下特点：  
+ 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。  
+ 对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度TD(v<sub>i</sub>)。  
+ 对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度OD(v<sub>i</sub>)（或入度ID(v<sub>i</sub>)）。  
+ 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。  
+ 稠密图适合用邻接矩阵的存储表示。  
+ 设图G的邻接矩阵为A，A<sup>n</sup>的元素A<sup>n</sup>[i][j]等于由顶点i到顶点j的长度为n的路径的数目。