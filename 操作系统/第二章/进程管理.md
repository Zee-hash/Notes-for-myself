# 进程管理
---
## 进程与线程
### 进程的概念  
在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。  
为了使参与并发执行的程序（含数据）能独立地运行，必须配置一个专门的数据结构，称之为进程控制块Process Control Block。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像(进程实体)。所谓创建进程，实质上是创建进程映像中的PCB。  
**进程是进程实体的运行过程，是系统进行资源分配和调度的一个基本单位**  
进程的其它定义：  
+ 进程是程序的一次执行过程
+ 进程是一个程序及其数据在处理机上顺序执行所发生的活动
+ 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位  
### 进程的特征  
+ 动态性。进程是程序的一次执行，它有着创建、阻塞、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。**动态性是进程最基本的特征**  
+ 并发性。之多个进程同时存在与内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用效率。  
+ 独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡是未建立PCB的程序，都不能作为一个独立的单位参与运行。  
+ 异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。  
+ 结构性。每个进程配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。  
### 进程的状态与转换  
进程在其生命周期内，由于系统中个进程之间的相互制约关系及系统运行环境的变化，使得进程的状态也在不断地发生改变。进程的状态通常有以下五种，其中前三种是进程的基本状态。  
+ 运行态。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。  
+ 就绪态。进程已处于准备运行的状态，即进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行。  
+ 阻塞态。进程正在风带某一事件而暂停运行，如等待某资源为可用(除处理机之后的其他资源)或等待输入/输出完成。进程处于阻塞态时，及时得到处理机，也不能运行。  
+ 创建态。进程正在被创建，尚未转到就绪态。创建进程通常包含多个步骤：  
  - 申请空白的PCB
  - 向PCB中写入控制和管理进程的信息
  - 系统为进程分配运行所需的资源
  - 分配成功进程即可转入就绪态  
+ 结束态。进程正在从系统中消失，可能是进程正常结束或其他原因中断运行。进程需要结束运行时，系统首先需要置该进程为结束态，然后进一步处理释放资源和回收等工作。  
#### 转化条件：  
+ 就绪态->运行态：处于就绪态的进程被调度后，得到处理机资源。  
+ 进行态->就绪态：处于运行态的进程在分配给它的时间片用完之后，让出处理剂。在可剥夺的操作系统中，如果有更高优先级的进程处于就绪态时，则会转去执行更高优先级的进程，当前进程则转入就绪态。  
+ 运行态->阻塞态：进程请求某一资源的使用和分配或等待某一事件发生时。进程通过系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核的形式。  
+ 阻塞态->就绪态：进程等待的事件到来时，**中断处理程序**就把相应进程的状态由阻塞态转换为就绪态。  
### 进程控制
进程控制的主要功能是对系统中所有的进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
1. 进程的创建  
允许一个进程创建另一个进程。创建进程的称为父进程，被创建的进程称为子进程。**子进程可以继承父进程所拥有的资源**。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。父进程一旦被撤销，其子进程也必须同时被撤销。  
在操作系统中，**终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等**都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语）：  
+ 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB。若PCB申请失败，则创建失败。  
+ 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（相关信息将存储在PCB中）。若资源不足，进程则处于阻塞态。  
+ 初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。  
+ 若进程就须队列能够接纳新进程，则将新进程插入就绪队列，等待被调度。  
2. 进程的终止  
引起进程终止的事件主要有：  
+ 正常结束，表示进程的任务已经完成并准备退出运行。  
+ 异常结束，标识进程在运行时，发生了某种异常事件，是程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。  
+ 外界干预，进程应外界的请求而终止运行。  
操作系统终止进程的过程如下（撤销原语）：  
+ 根据被终止进程的标识符，检索PCB，从中读出进程的状态。  
+ 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。  
+ 若该进程还有子进程，则应把其所有子进程终止。  
+ 将该进程所拥有的全部资源归还给其父进程，或归还给操作系统。  
+ 将该PCB从所在队列（链表）删除。  
3. 进程的阻塞和唤醒  
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做等，有系统自动执行阻塞原语(Block)，使自己由运行态变成阻塞态。**可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程，才有可能将其转为阻塞态。阻塞原语的执行过程如下：  
+ 找到将要被阻塞进程的标识号对应的PCB。  
+ 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。  
+ 把该PCB插入相应事件的等待队列。  
当被阻塞进程所期待的事件发生时，由有关进程（如提供数据的进程）调用唤醒原语(Wakeup)，将等待该时间的进程唤醒。唤醒原语的执行过程如下：  
+ 在该事件的等待队列找到相应进程的PCB。  
+ 将其从等待队列移除，并置其状态为就绪态。  
+ 把该PCB插入就绪队列，等待调度程序调度。  
**Block原语是由被阻塞进程自我调用实现的，Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的**  
4. 进程切换  
进程切换是指处理机从一个进程的运行切换到另一个进程上运行，在这个过程中，进程的运行环境发生了实质性的变化。进程切换的过程如下：  
+ 保存处理机上下文，包括程序计数器和其他寄存器。  
+ 更新PCB信息。  
+ 把进程的PCB移入相应的队列，如就绪、某事件的阻塞队列。  
+ 选择另一个进程执行，并更新其PCB。   
+ 更新内存管理的数据结构。  
+ 恢复处理机上下文。  
### 进程的组织  
进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它一般由以下三部分组成：  
1. 进程控制块  
进程创建时，操作系统新建一个PCB结构，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。**PCB是进程实体的一部分，是进程存在的唯一标志**。  
创建一个进程时，系统为该进程建立一个PCB；进程执行时，系统通过PCB了解现行状态信息，以便对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程。  
PCB通常包含的内容：  
+ 进程描述信息。  
  - 进程标识符PID
  - 用户标识符UID  
+ 进程控制和管理信息  
  - 代码当前状态
  - 进程优先级
  - 代码运行入口地址
  - 程序的外存地址
  - 进入内存时间
  - 处理机占用时间
  - 信号量使用  
+ 资源分配清单  
  - 代码段指针
  - 数据段指针
  - 堆栈段指针
  - 文件描述符
  - 键盘
  - 鼠标  
+ 处理机相关信息  
  - 通用寄存器值
  - 地址寄存器值
  - 控制寄存器值
  - 标志寄存器值
  - 状态字  
为了方便进程的管理和调度，需要将各进程的PCB用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。  
+ 链接方式：将同一状态的PCB链接成一个队列，不同的状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。  
+ 索引方式：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同众状态对应不同的索引表，如就绪索引表和阻塞索引表。  
2. 程序段  
程序段就是能够被进程调度程序调度到CPU执行的程序代码段。**程序可被多个进程共享，即多个进程可以运行同一个程序**。  
3. 数据段  
一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是进程执行产生的中间或最终结果。
### 进程的通信  
进程通信指的是进程之间的信息交换。PV操作是低级通信方式，高级通信方式时指出以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。  
1. 共享存储  
在通信的进程之间存在一块可被直接访问的存储空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时，需要使用同步互斥工具，对共享空间的读/写进行控制。共享存储又分为两种：  
+ 基于数据结构的共享  
+ 基于存储区的共享  
操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则需要由用户自己安排读/写指令完成。  
**用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，要想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。**  
2. 消息传递  
在消息传递系统中，进程间的数据交换是以格式化的消息为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法来实现进程的通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。  
+ 直接通信方式。发送进程直接把消息发送给接收进程，并把它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。  
+ 间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。计算机网络中的一种应用为电子邮件系统。  
3. 管道通信  
管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。  
在Linux中，管道是一种使用非常频繁的通信机制。从本质上来说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下：  
+ 限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux系统中，该缓冲区的大小为4KB，这使得它的大小不像一般文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用。  
+ 读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。  
在管道通信中，存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中还有数据，进程就能够从缓冲区中读出，而不必担心会因为其它进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。这决定了管道通信是半双工的。  
### 线程概念和多线程模型  
1. 线程的基本概念  
引入线程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量，增加并发程度；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。  
线程最直接的理解就是“轻量级进程”。它是一个基本的CPU执行单位，也是程序执行流的最小单位，由**线程ID、程序计数器、寄存器集合和堆栈**组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。  
引入线程后，进程的内涵发生了改变，**进程只作为除CPU外的系统资源的分配单元，线程则作为处理机的分配单元**。由于一个进程内部有多个线程，若线程的切换发生在同一进程内部，则只需要很少的时空开销。  
2. 进程与线程的比较  
+ 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中进行线程切换，会引起进程切换。  
+ 拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位。而线程不拥有系统资源（仅拥有必不可少的资源），但线程可以访问其所属进程的系统资源。  
+ 并发性。在引入线程的操作系统中，不见线程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。  
+ 系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换时，涉及当前进程的CPU环境的保存以及新调度到进程CPU环境的设置，而线程切换时仅需保存和设置少量寄存器的内容，开销很小。此外，由于同一个进程内的多个线程共享进程的地址空间，因此这些线程之间的同步和通信非常容易实现，甚至无需操作系统的干预。  
+ 地址空间和其他资源。进程的地址空间之间相互独立，同一进程的各线程共享进程的资源，某进程内的线程对于其他进程不可见。  
+ 通信方面。进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的统一性，而线程间可以直接读/写进程数据段来进行通信。  
3. 线程的属性  
线程的主要属性如下：  
+ 线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的状态标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。  
+ 不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。  
+ 同一个进程中的各个线程共享该进程所拥有的资源。  
+ 线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。  
+ 一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。  
4. 线程的实现方式  
线程的实现可以分为两类：用户级线程User-Level Thread和内核级Kernel-Level Thread。内核级线程又称内核支持的线程。  
在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行期间，可以通过调用线程库中的派生例程创建一个在相同进程运行的新线程。  
在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。  
有些系统使用组合方式的多线程实现。线程创建完全在用户空间内完成。线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射一些到内核级线程上。  
5. 多线程模型  
有些系统同时支持用户级线程和内核级线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。  
+ 多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户线程对操作系统不可见。  
优点：线程管理是在用户空间完成的，因而效率较高。  
缺点：一个线程在使用内核服务时被阻塞，整个进程都会被阻塞；多个线程不能并行地运行在多处理上。  
+ 一对一模型。将每个用户级线程映射到一个内核级线程。  
优点：当一个线程被阻塞后，运行另一个线程继续执行，因此并发能力较强。  
缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。  
+ 多对多模型。将n个用户级线程映射到m个内核级线程上，要求m<=n。  
特点：这种方式既克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程而开销太大的缺点。此外，还拥有上述两种模型的优点。

---
## 处理机调度
### 调度的概念  
1. 调度的基本概念  
在多道程序系统中，进程的数量往往多于处理机的数量，因此进程争用处理机的情况在所难免。处理机调度是对**处理机**进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程的并发地执行。  
处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。  
2. 调度的层次  
一个作业从提交到完成，往往要经历以下三级调度。  
+ 作业调度（高级调度）。其主要任务是按照一定的原则从**外存**上处于后备队列的作业中挑选一个或多个作业，为它们分配内存、输入输出设备等必要的资源，并建立相应的进程，使得它们获得竞争处理机的权利。**作业调度是内存和辅存之间的调度，每个作业只能调入一次、调出一次。**  
+ 中级调度（内存调度）。其作用是提高内存利用率和系统吞吐量。为此，应将那些暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起态。当它们已具备条件且内存又稍有空闲时，由中级调度来决定把外存上那些已具备运行条件的挂起态进程，再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。  
+ 进程调度（低级调度）。其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率一般很高。  
3. 三级调度的联系  
**作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入到就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间教宽松时，通过中级调度选择具有运行条件的进程，将其唤醒。**  
+ 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。  
+ 作业调度次数少，中级调度次数略多，进程调度频率最高。  
+ 进程调度是最基本的，不可或缺。  
### 调度的时机、切换与过程  
进程调度和切换程序是操作系统内核程序。请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪程序之后，才会进行进程间的切换。  
现代操作系统中，不能进行进程的调度和切换的情况有以下几种：  
+ 在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。  
+ 进程在操作系统内核程序临界区中。进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其它并行程序进入，在解锁前不应切换到其他进程运行，以加快共享数据的释放。  
+ 其他需要完全屏蔽中断的原子操作的过程中。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，中断也会被屏蔽。  
若上述过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。  
应该进行进程调度与切换的情况如下：  
+ 发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是非剥夺调度。  
+ 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了剥夺方式的调度。  
**进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的线程信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。  
### 进程调度方式  
+ 非剥夺调度方式。又称非抢占方式，非剥夺调度方式是指当一个进程正在处理机上执行时，即使有更为重要或迫切的进程进入就绪队列，仍然让正在执行的进程继续执行，知道该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或迫切的进程。  
在这种方式下，一旦把CPU分配给一个进程，该进程就会保持CPU直到终止或转换到等待态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统或大多数的实时系统。  
+ 剥夺调度方式。又称抢占方式，剥夺调度方式是指当一个进程正在处理上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立刻暂停正在执行的进程，将处理机分配给这个更为重要或迫切的进程。  
采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一个任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。  
### 调度的基本准则  
准则主要用来评价处理机调度算法。  
+ CPU利用率，应尽可能地使得CPU保持忙的状态，使其资源利用率最高。  
+ 系统吞吐量，**表示单位时间内CPU完成作业的数量**。长作业需要消耗较长的处理机时间，因此会降低系统吞吐量。而对于短作业，它们所需要消耗的处理机时间比较短，因此能提高系统吞吐量。  
+ 周转时间，**从作业提交到作业完成所经历的时间**,是作业等待、在就绪队列中排队、在处理机上运行及进行输入输出操作所花费时间的总和。  
**周转时间=作业完成时间-作业提交时间**  
**平均周转时间=作业周转时间之和/作业个数**  
**带权周转时间=作业周转时间/作业实际运行时间**  
**平均带权周转时间=作业带权周转周期之和/作业个数**  
+ 等待时间，**等待时间是指进程处于等处理机状态的时间之和**，等待时间越长，用户满意度越低。处理机调度算法实际并不影响作业执行或输入输出操作的时间，只影响作业在就绪队列中等待所花的时间。  
+ 响应时间，响应时间是指**从用户提交请求到系统首次产生响应所用的时间**。在交互式系统中，这项指标是衡量调度算法的重要指标之一。  

