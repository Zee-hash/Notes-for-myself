# 指令系统  
---  
## 指令格式  
指令（又称机器指令）是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是计算机的主要属性，位于硬件和软件的交界面上。  
### 指令的基本格式  
一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分：  

|操作码字段|地址码字段|  
|---|---|  

其中，操作码字段指出指令中该指令应该执行什么性质的操作和具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信心。  
地址码给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移指令、被调用的子程序的入口地址等。  
指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。**指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长**。通常，把指令长度等于机器字长的机器称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令。  
在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主存一般都是按字节编址的，所以指令字长多为字节的整数倍。  
根据指令中操作数地址码的数目的不同，可将指令分为以下几种格式。  
#### 零地址指令  

|OP|  
|---|  

只给出操作码OP，没有显式地址。这种指令有两种可能：  
+ 不需要操作数的指令，如空操作指令、停机指令、关中断指令  
+ 零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈  

#### 一地址指令  

|OP|A<sub>1</sub>|  
|---|---|  

这种指令也有两种常见的形态：  
+ 只有目的操作数的单操作数指令，按A<sub>1</sub>地址读取操作数，进行OP操作后，结果返回原地址。  
指令含义：OP（A<sub>1</sub>）-> A<sub>1</sub>  
如自增、自减、求反、求补运算  
+ 隐含约定目的地址的双操作数指令，按指令地址A<sub>1</sub>可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算的结果也将放在ACC中。
指令含义：（ACC）OP（A<sub>1</sub>） -> ACC  
若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为2<sup>24</sup>=16M  
#### 二地址指令  

|OP|A<sub>1</sub>|A<sub>2</sub>|  
|---|---|---|  

指令含义：（A<sub>1</sub>）OP（A<sub>2</sub>） -> A<sub>1</sub>  
对于常用的算术和逻辑运算，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次运算结果。  
#### 三地址指令  

|OP|A<sub>1</sub>|A<sub>2</sub>|A<sub>3</sub>  
|---|---|---|---|  

指令含义：（A<sub>1</sub>）OP（A<sub>2</sub>） -> A<sub>3</sub>  
若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令一次，取两个操作数两次，存放结果1次）  
#### 四地址指令  

|OP|A<sub>1</sub>|A<sub>2</sub>|A<sub>3</sub>|A<sub>4</sub>|  
|---|---|---|---|--|  

指令含义：（A<sub>1</sub>）OP（A<sub>2</sub>） -> A<sub>3</sub>  ，A<sub>4</sub>=下一条将要执行指令的地址  

### 定长操作码指令格式  
定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般n位操作码字段的指令系统最大能够表示2<sup>n</sup>条指令。  
定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。  
### 扩展操作码指令格式  
为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。  
最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而有所增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。  
在设计扩展操作码指令格式时，必须注意以下两点：  
+ 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同  
+ 各指令的操作码一定不能重复  

通常情况下，**对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。**  

---  
## 指令的寻址方式  
寻址方式是指寻找指令或操作数有效地址的方式，即**确定本条指令的数据地址及下一条待执行指令的地址**的方法。寻址方式分为指令寻址和数据寻址两大类。  
指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA)。  
(A)表示地址为A的数值，A即可以是寄存器编号，也可以是内存地址。对应的(A)就是寄存器中的数值或相应内存单元中的数值。EA=(A)意思是有效地址就是地址A中的数值。  
### 指令寻址和数据寻址  
寻址方式分为指令寻址和数据寻址两大类。寻找下一条将要执行的指令地址称为指令寻址；寻找操作数的地址称为数据寻址。  
#### 指令寻址  
指令寻址分为两种方式：一种是顺序寻址方式，另一种是跳跃寻址方式。  
+ 顺序寻址方式可通过程序计数器（PC）加1（一个指令字长），自动形成下一条指令的地址。  
+ 跳跃寻址通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到）和相对寻址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC值，**所以下一条指令仍然通过程序计数器PC给出**。  
#### 数据寻址  
数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。  
数据寻址的方式较多，为区别各种方式，通常在指令中设一个字段，用来指明属于哪种寻址方式，由此可得指令的格式如下所示：  

|操作码|寻址特征|形式地址A|  
|---|---|---|  

### 常见的数据寻址方式  
#### 隐含寻址　　
这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。  
隐含寻址的有限在于有利于缩短指令字长；缺点是需增加存储操作数或隐含地址的硬件。  
#### 立即寻址  
这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数。**数据采用补码形式存放**。  

|OP|#|A|  
|---|---|---|  

其中#表示立即寻址特征，A就是操作数本身。  
立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短；缺点是A的位数限制了立即数的范围。  
#### 直接寻址  
指令字中的形式地址A是操作数的真实地址EA，即EA=A  
直接寻址的优点是简单，指令在执行期间仅访问一次主存，不需要专门计算操作数的地址；缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。  
#### 间接寻址  
间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。间接寻址可以是一次间接寻址，还可以是多次间接寻址。  
间接寻址的优点是可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间接寻址可方便地完成子程序返回）；缺点是指令在执行阶段需要多次访存（一次间接寻址需要两次访存，多次间接寻址需根据存储字的最高位确定访存次数）。由于访存速度过慢，这种寻址方式并不常用。  
#### 寄存器寻址  
寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即EA=R<sub>i</sub>，其操作数在由R<sub>i</sub>所指的寄存器内。  
寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，**支持向量/矩阵运算**；缺点是寄存器价格昂贵，计算机中的寄存器个数有限。  
#### 寄存器间接寻址  
寄存器间接寻址是指在寄存器R<sub>i</sub>中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R<sub>i</sub>)。  
寄存器间接寻址的特点是，与一般的间接寻址相比速度更快，但指令的执行阶段需要访问主存。  
#### 相对寻址  
相对寻址是指把程序计数器（PC）的内容加上指令格式中的形式地址A而形成的有效地址，即EA=(PC)+A，其中A是相对于当前指令地址的偏移量，可正可负，补码表示。  
A的位数决定操作数的寻址范围。  
相对寻址的优点是操作数的地址不是固定的，它随PC值的变换而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。**相对寻址广泛应用于转移指令**。  
**对于转移指令JMPA，当CPU从存储器中取出一字节时，会自动执行(PC)+1->PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会增2，即(PC)=X+2，这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。**  
#### 基址寻址  
基址寻址是指将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(BR)+A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。  
**基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。** 在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。  
基址寻址的优点是可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序位于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。  
#### 变址寻址  
变址寻址是指有效地址EA等于指令字中形式地址A与变址寄存器IX的内容之和，即EA=(IX)+A，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。  
**变址寄存器时面向用户的，在程序执行的过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。**  
变址寄存器的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量（变址寄存器IX）的位数足以表示整个存储空间。  
变址寻址和基址寻址的区别：  
+ 基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常是由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中A是可变的。  
+ 变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。  
#### 堆栈寻址  
堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出LIFO原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为硬堆栈和软堆栈两种。  
寄存器堆栈又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈；而在主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。  
在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。  
### X86汇编指令入门  
#### 相关寄存器  
X86处理器中有8个32位的通用寄存器。为了向后兼容，EAX、EBX、ECX和EDX的高两位字节和低两位字节可以独立使用，E为Extended，表示32位的寄存器。寄存器的名称与大小写无关。除EBP和ESP外，其他几个寄存器的用途是比较任意的。  

|00000000|00000000|00000000|00000000|  
|---|---|---|---|
|EAX|累加器 Accumulator|AH|AL|  
|EBX|基地址寄存器 Base Register|BH|BL|  
|ECX|计数寄存器 Count Register|CH|CL|  
|EDX|数据寄存器 Data Register|DH|DL|  
|ESI|变址寄存器 Index Register|  |  |  
|EDI|变址寄存器 Index Register|  |  |  
|EBP|堆栈基指针 Base Pointer|  |  |  
|ESP|堆栈顶指针 Stack Pointer|  |  |  

#### 寻址模式和内存分配  
##### 寻址模式  
X86提供了一种灵活的内存寻址方式，以mov指令为例，mov用于在内存和寄存器之间移动数据，它有两个参数，**第一个是目的地址，第二个是源地址。**  
最多只能利用两个32位寄存器和一个32位的有符号常数相加计算出一个内存地址。  
即  
+ 寄存器之间只有相加运算  
+ 最多只能有两个寄存器参与运算  
##### 数据类型长度规定  
在汇编语言中声明内存大小时，一般显式地使用DB(Data Byte)、DW(Data Word)和DD(Data Double Word)分别表示一个字节、两个字节和四个字节的内存空间。  
X86提供了三个指示规则标记，分别为byte ptr、word ptr、dword ptr。  
`mov byte ptr [ebx], 2`将2以单字节形式传送到ebx值指示的内存地址中  
`mov word ptr [ebx], 2`将2以双字节形式传送到ebx值指示的内存地址中  
`mov dword ptr [ebx], 2`将2以四字节形式传送到ebx值指示的内存地址中  
##### 常用指令  
汇编指令通常分为数据传送指令、逻辑计算指令和控制流指令。  
`<reg>`表示任意寄存器，若其后带有数字，则指定其位数。  
`<mem>`表示内存地址。  
`<con>`表示8位、16位或32位常数。   
+ 数据传送指令  
  - mov  
  mov指令将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。但**不能用于直接从内存复制到内存。**  
  语法如下：  
  ·`mov <reg>,<reg>`  
  ·`mov <reg>,<mem>`  
  ·`mov <mem>,<reg>`  
  ·`mov <reg>,<con>`  
  ·`mov <mem>,<con>`  
  - push  
  push指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前先将ESP减4（栈增长方向与内存地址增长方向相反），然后将操作数压入ESP指示的地址。  
  语法如下：  
  `push <reg>`  
  `push <mem>`  
  `push <con32>`  
  - pop  
  与push指令相反，pop指令执行的是出栈工作，出栈前首先将ESP指示的内容出栈，然后将ESP的值加4。  
+ 算术和逻辑运算指令  
  - add/sub  
  add将两个操作数相加，相加的结果保存在第一个操作数中。sub指令用于两个操作数相减，相减的结果保存在第一个操作数中。  
  - inc/dec  
  inc、dec指令分别表示操作数自加1、自减1。  
  - imul  
  带符号整数乘法指令，它有两种格式：两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器；三个操作数，将第二个操作数和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器。  
  乘法操作结果可能溢出，则编译器置溢出标志OF=1,以使CPU调出溢出异常处理程序。  
  - idiv  
  带符号整数除法指令，它有一个操作数，即除数，而被除数则为**edx:eax**中的内容内容（64位整数），操作结果有两部分：商和余数，商送到eax，余数则送到edx。  
  - and/or/xor指令  
  逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。  
  - not  
  位翻转指令，将操作数中的每一位翻转。  
  - neg  
  取负指令。  
  - shl/shr  
  逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。  
+ 控制流指令  
X86处理器维持着一个指示当前执行指令的指令指针IP，当一条指令执行后，此指针就自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签label指示程序中的指令地址，在X86汇编代码中，可在任何指令前加入标签。  
  - jump  
  控制IP转移到所指示的地址（从label中取出指令执行）。  
  - jcondition指令  
  条件转移指令，它依据处理机状态字中的一系列条件状态转移。处理机状态字中包括指示最后一个算数运算结果是否为0,运算结果是否为负数等。  
  `je <label>`jump when euqal  
  `jne <label>`jump when not equal  
  `jz <lzbel>`jump when last result was zero  
  `jg <label>`jump when greater than  
  `jge <label>`jum when greater than or equal to  
  `jl <label>`jump when less than  
  `jle <label>`jump when less than or equal to  
  - cmp  
  比较两个操作数的值，并根据比较结果设置处理机状态子中的条件码。通常与jcondition指令搭配使用。  
  - call/ret  
  这两条指令实现子程序（过程、函数等）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其他简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回调用之前的地址）。ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call和ret是函数调用中最关键的两条指令。  

  ---  
  ## CISC和RISC的基本概念  
  