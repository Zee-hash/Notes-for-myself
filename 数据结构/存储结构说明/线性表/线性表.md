# 线性表  
## 顺序表  
### 顺序表的定义    
> 线性表的顺序存储又称顺序表。它是用一组连续的存储单元一次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。  

假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：  
```C  
#define MaxSize 50// 定义线性表的最大长度  
typedef struct{
    ElemType data[MaxSize];// 顺序表的元素
    int length;// 顺序表的当前长度
}SqList;// 顺序表的类型定义
```  
若采用动态分配，存储数组的空间是在程序执行过程中通过动态存储分配语句功能分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。  
```C
#define InitSize 100//表长度的初始定义
typedef struct{
    ElemType *data;// 指示动态分配数组的指针
    int MaxSize, length;// 数组的最大容量和当前元素个数
}SeqList;  
```  
C的初始动态分配语句为  
```C
L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);
```
C++的初始动态分配语句为  
```C++
L.data = new ElemType[InitSize];
```
### 顺序表的基本操作的实现  
### 插入操作  
> **插入位置`i`表示在第i个位置插入新元素e**


```C
bool ListInsert(SqList &L, int i, ElemType e)
{
    if(i < 1 || i > L.length + 1)
    {
        return false;// 插入位置无效
    }
    if(L.length >= MaxSize)
    {
        return false;// 存储空间已满
    }
    for(int j = L.length; j >= i; j--)
    {
        L.data[j] = L.data[j-1];// 向后移动元素，留出空位
    }
    L.data[i-1] = e;// 插入元素放到正确位置  
    L.length++;// 表中元素个数+1  
    return true;
}
```  
最好情况：在表尾插入，i=n+1，元素后移操作不需执行，时间复杂度为O(1)。  
最坏情况：在表头插入，i=1，所有元素均需后移，时间复杂度为O(n)。  
平均情况：假设在各位置插入元素的概率相等，1<=i<=n+1，则需移动结点的平均次数为[n(n+1)] / [2(n+1)] = n / 2。  
#### 删除操作  
> **删除顺序表L中第`i`个位置的元素，引用变量e用于返回被删除的元素**  

```C
bool ListDelete(SqList &L, int i, ElemType &e)
{
    if(i < 1 || i > L.length)
    {
        return flase;// 删除位置不合法
    }
    e = L[i-1];// 保存被删除元素
    for(int j = i; j < L.length; j++)
    {
        L[j-1] = L[j];// 向前移动元素，补齐空位
    }
    L.length--;
    return true;
}
```
最好情况：删除表尾元素，i=n，无需移动元素，时间复杂度为O(1)。  
最坏情况：删除表头元素，i=1，所有后续n-1个元素需移动，时间复杂度为O(n)。  
平均情况：假设删除各位置结点的概率相等，1<=i<=n，所需移动结点的平均次数为[(n-1+1)(n-1)] / 2n = (n-1) / 2。  
#### 按值查找（顺序查找）  
> **在顺序表L中查找第一个元素值等于e的元素，并返回其位序(第几号元素)**  

```C
int LocateElem(SqList L, ElemType e)
{
    int i;
    for(i = 0; i < L.lenght; i++)
    {
        if(L.data[i] == e)
        {
            return i+1;// 查找成功，返回位序
        }
    }
    return 0;// 退出循环，即查找失败
}
```  
最好情况：查找的元素就是表头，此时时间复杂度为O(1)。  
最坏情况：在表尾或不存在时，时间复杂度为O(n)。  
平均情况：假设查找的元素在第i个位置上的概率相等，则查找所需比较的平均次数为(n+1) / 2。  

## 单链表  
### 单链表的定义  
> 线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继元素的指针。  

单链表中结点类型的描述如下：  
```C
typedef struct LNode{
    ElemType data;// 数据域
    struct LNode * next;// 指针域
}LNode, *LinkList;
```
通常用头指针来标识一个单链表，如链表L，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之间附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。  
**头指针和头结点的区别：不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。**  
引入头结点后，可以带来两个优点：  
+ 由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表上的第一个位置上的操作和在表的其他位置的操作一致，无需进行特殊处理。  
+ 无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理就得到了统一。  

### 单链表上基本操作的实现  
### 头插法建立单链表  
> 从一个空表开始，生成新结点（动态），并将读取到的数据存放到新生成结点的数据域中，再将新结点插入到表头，即头结点之后。  

```C
LinkList List_HeadInsert(LinkList &L)
{
    LNode *s; int x;
    L = (LinkList)malloc(sizeof(LNode));// 创建头结点  
    L->next = NULL;// 初始化为空链表
    scanf("%d", &x);
    while(x != 9999)// 输入9999表示结束
    {
        s = (LinkList)malloc(sizeof(LNode));// 创建新结点  
        s.data = x;// 填充数据域
        s->next = L->next;// 新结点指针域指向头结点后继元素
        L->next = s;// 头结点指针域指向新结点
        scanf("%d", &x);
    }
    return L;
}
```
采用头插法建立单链表时，读入数据的顺序与生成的链表的元素的顺序是相反的。每个结点插入的时间复杂度为O(1)，设单链表长度为n，则总时间复杂度为O(n)。  
#### 尾插法建立单链表
> 由于头插法生成的链表中结点的次序和输入数据的顺序不一致，因此，若希望两者的次序一致，可以采用尾插法。**为了将新结点插入到当前链表的末尾，增加一个尾指针r始终指向当前链表的尾结点。**  

```C
LinkList List_TailInsert(LinkList &L)
{
    int x;
    L = (LinkList)malloc(sizeof(LNode));
    LNode *s, *r = L;// r为尾指针  
    scanf("%d", &x);
    while(x != 9999)
    {
        s = (LinkList)malloc(sizeof(LNode));
        s->data = x;
        r->next=s;// 当前尾结点后新增元素
        r=s;// r重新指向末尾
        scanf("%d", &x);
    }
    r->next = NULL;// 尾结点指针置空
    return L;
}
```
因为附设了一个指向表尾结点的指针，故时间复杂度和头插法相同。  
#### 按序号查找结点值  
> 在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。  

```C
LNode *GetElem(LinkList L, int i)
{
    int j = 1;
    LNode *p = L->next;// 头结点指针赋给p
    if(i==0)
    {
        return p;// 返回头结点
    }
    if(i < 1)
    {
        return NULL;// i无效，返回NULL
    }
    while(p && j < i)// 从第一个结点开始找，查找第i个结点
    {
        p = p->next;
        j++;
    }
    return p;// 找到即返回正确的指向第i个结点的指针，超出范围值返回NULL(链表最后一个结点的指针域指向NULL)。
}
```  
按序号查找操作的复杂度为O(n)。  
#### 按值查找表结点  
> 从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。  

```C
LNode *LocateElem(LinkList L, ElemType e)
{
    LNode *p = L->next;
    while(p->next&&p->data!=e)
    {
        p = p->next;// 从第一个结点开始查找data域为e的结点。
    }
    return p;// 查找成功则返回该结点的指针，否则返回NULL
}
```  
按值查找操作的时间复杂度为O(n)。  
#### 插入结点操作  
> 插入结点操作将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到的待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。  

```C
p = GetElem(L, i-1);// 查找待插入位置前驱结点
s->next = p->next;// 插入新结点
p->next = s;
```  
本算法主要时间开销在于查找第i-1个元素，时间复杂度为O(n)。找到结点后，在其后插入元素的时间复杂度为O(1)。  
> 扩展：对某一结点进行前插操作  

前插操作是指在某结点的前面插入一个新的结点。在单链表的插入算法中，通常都采用后插操作。  
以上面的算法为例，首先调用函数GetElem()找到第i-1个结点，即插入操作的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作操作均可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。  
此外，可采用另一种方式将其转化为后插操作实现，设待插入结点为*s，将*s插入到*p(此时已有指向p的指针)的前面。**将*s插入到*p的后面，然后将p->data与s->data交换，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。  
```C
s->next = p->next;// 正常执行后插
p->next = s;
temp = p->data;// 交换数据域部分
p->data = s->data;
s->data = temp;
```  
#### 删除结点操作  
> 删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除。  

```C
p = GetElem(L, i-1);// 查找删除位置的前驱结点  
q = p->next;// 令q指向被删除结点
p->next = q->next;// 将*q从链中断开
free(q);// 释放结点的存储空间
```  
和插入算法一样，算法的主要时间耗费在查找操作上，时间复杂度为O(n)。  
> 扩展：删除结点*p  

要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序查找到其前驱结点，然后再执行删除操作，算法的时间复杂度为O(n)。  
采用和上述前插法类似的操作，仍删除*p的后继结点，但在删除之间将其后继元素的数据域信息赋给自身，再删除其后继结点，也能使得算法复杂度为O(1)。  
```C
q = p->next;// 令q指向其后继结点
p->data = q->data;// 获取后继结点的数据信息
p->next = q->next;// 将*q结点从链中断开
free(q);// 释放后继结点的存储空间
```  
#### 求表长操作  
> 求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的复杂度为O(n)。  

由于单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上回略有不同。对不带头结点的单链表，当表为空时，要单独处理。