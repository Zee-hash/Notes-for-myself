# 进程管理
---
## 进程与线程
### 进程的概念  
在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。  
为了使参与并发执行的程序（含数据）能独立地运行，必须配置一个专门的数据结构，称之为进程控制块Process Control Block。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像(进程实体)。所谓创建进程，实质上是创建进程映像中的PCB。  
**进程是进程实体的运行过程，是系统进行资源分配和调度的一个基本单位**  
进程的其它定义：  
+ 进程是程序的一次执行过程
+ 进程是一个程序及其数据在处理机上顺序执行所发生的活动
+ 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位  
### 进程的特征  
+ 动态性。进程是程序的一次执行，它有着创建、活塞、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。**动态性是进程最基本的特征**  
+ 并发性。之多个进程同时存在与内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用效率。  
+ 独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡是未建立PCB的程序，都不能作为一个独立的单位参与运行。  
+ 异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。  
+ 结构性。每个进程配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。  
### 进程的状态与转换  
进程在其生命周期内，由于系统中个进程之间的相互制约关系及系统运行环境的变化，使得进程的状态也在不断地发生改变。进程的状态通常有以下五种，其中前三种是进程的基本状态。  
+ 运行态。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。  
+ 就绪态。进程已处于准备运行的状态，即进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行。  
+ 阻塞态。进程正在风带某一事件而暂停运行，如等待某资源为可用(除处理机之后的其他资源)或等待输入/输出完成。进程处于阻塞态时，及时得到处理机，也不能运行。  
+ 创建态。进程正在被创建，尚未转到就绪态。创建进程通常包含多个步骤：  
  - 申请空白的PCB
  - 向PCB中写入控制和管理进程的信息
  - 系统为进程分配运行所需的资源
  - 分配成功进程即可转入就绪态  
+ 结束态。进程正在从系统中消失，可能是进程正常结束或其他原因中断运行。进程需要结束运行时，系统首先需要置该进程为结束态，然后进一步处理释放资源和回收等工作。  
#### 转化条件：  
+ 就绪态->运行态：处于就绪态的进程被调度后，得到处理机资源。  
+ 进行态->就绪态：处于运行态的进程在分配给它的时间片用完之后，让出处理剂。在可剥夺的操作系统中，如果有更高优先级的进程处于就绪态时，则会转去执行更高优先级的进程，当前进程则转入就绪态。  
+ 运行态->阻塞态：进程请求某一资源的使用和分配或等待某一事件发生时。进程通过系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核的形式。  
+ 阻塞态->就绪态：进程等待的事件到来时，**中断处理程序**就把相应进程的状态由阻塞态转换为就绪态。  
### 进程控制
进程控制的主要功能是对系统中所有的进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
1. 进程的创建  
允许一个进程创建另一个进程。创建进程的称为父进程，被创建的进程称为子进程。**子进程可以继承父进程所拥有的资源**。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。父进程一旦被撤销，其子进程也必须同时被撤销。  
在操作系统中，**终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等**都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语）：  
+ 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB。若PCB申请失败，则创建失败。  
+ 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（相关信息将存储在PCB中）。若资源不足，进程则处于阻塞态。  
+ 初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。  
+ 若进程就须队列能够接纳新进程，则将新进程插入就绪队列，等待被调度。  
2. 进程的终止  
引起进程终止的事件主要有：  
+ 正常结束，表示进程的任务已经完成并准备退出运行。  
+ 异常结束，标识进程在运行时，发生了某种异常事件，是程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。  
+ 外界干预，进程应外界的请求而终止运行。  
操作系统终止进程的过程如下（撤销原语）：  
+ 根据被终止进程的标识符，检索PCB，从中读出进程的状态。  
+ 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。  
+ 若该进程还有子进程，则应把其所有子进程终止。  
+ 将该进程所拥有的全部资源归还给其父进程，或归还给操作系统。  
+ 将该PCB从所在队列（链表）删除。  
3. 进程的阻塞和唤醒  
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做等，有系统自动执行阻塞原语(Block)，使自己由运行态变成阻塞态。**可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程，才有可能将其转为阻塞态。阻塞原语的执行过程如下：  
+ 找到将要被阻塞进程的标识号对应的PCB。  
+ 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。  
+ 把该PCB插入相应事件的等待队列。  
当被阻塞进程所期待的事件发生时，由有关进程（如提供数据的进程）调用唤醒原语(Wakeup)，将等待该时间的进程唤醒。唤醒原语的执行过程如下：  
+ 在该事件的等待队列找到相应进程的PCB。  
+ 将其从等待队列移除，并置其状态为就绪态。  
+ 把该PCB插入就绪队列，等待调度程序调度。  
**Block原语是由被阻塞进程自我调用实现的，Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的**  
4. 进程切换  
进程切换是指处理机从一个进程的运行切换到另一个进程上运行，在这个过程中，进程的运行环境发生了实质性的变化。进程切换的过程如下：  
+ 保存处理机上下文，包括程序计数器和其他寄存器。  
+ 更新PCB信息。  
+ 把进程的PCB移入相应的队列，如就绪、某事件的阻塞队列。  
+ 选择另一个进程执行，并更新其PCB。   
+ 更新内存管理的数据结构。  
+ 恢复处理机上下文。  
### 进程的组织  
进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它一般由以下三部分组成：  
1. 进程控制块  
进程创建时，操作系统新建一个PCB结构，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。**PCB是进程实体的一部分，是进程存在的唯一标志**。  
创建一个进程时，系统为该进程建立一个PCB；进程执行时，系统通过PCB了解现行状态信息，以便对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程。  
PCB通常包含的内容：  
+ 进程描述信息。  
  - 进程标识符PID
  - 用户标识符UID  
+ 进程控制和管理信息  
  - 代码当前状态
  - 进程优先级
  - 代码运行入口地址
  - 程序的外存地址
  - 进入内存时间
  - 处理机占用时间
  - 信号量使用  
+ 资源分配清单  
  - 代码段指针
  - 数据段指针
  - 堆栈段指针
  - 文件描述符
  - 键盘
  - 鼠标  
+ 处理机相关信息  
  - 通用寄存器值
  - 地址寄存器值
  - 控制寄存器值
  - 标志寄存器值
  - 状态字  
为了方便进程的管理和调度，需要将各进程的PCB用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。  
+ 链接方式：将同一状态的PCB链接成一个队列，不同的状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。  
+ 索引方式：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同众状态对应不同的索引表，如就绪索引表和阻塞索引表。  
2. 程序段  
程序段就是能够被进程调度程序调度到CPU执行的程序代码段。**程序可被多个进程共享，即多个进程可以运行同一个程序**。  
3. 数据段  
一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是进程执行产生的中间或最终结果。
### 进程的通信  
进程通信指的是进程之间的信息交换。PV操作是低级通信方式，高级通信方式时指出以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。  
1. 共享存储  
在通信的进程之间存在一块可被直接访问的存储空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时，需要使用同步互斥工具，对共享空间的读/写进行控制。共享存储又分为两种：  
+ 基于数据结构的共享  
+ 基于存储区的共享  
操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则需要由用户自己安排读/写指令完成。  
**用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，要想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。**  
2. 消息传递  
在消息传递系统中，进程间的数据交换是以格式化的消息为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法来实现进程的通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。  
+ 直接通信方式。发送进程直接把消息发送给接收进程，并把它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。  
+ 间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。计算机网络中的一种应用为电子邮件系统。  
3. 管道通信  
管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。  
在Linux中，管道是一种使用非常频繁的通信机制。从本质上来说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下：  
+ 限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux系统中，该缓冲区的大小为4KB，这使得它的大小不像一般文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用。  
+ 读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。  
在管道通信中，存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中还有数据，进程就能够从缓冲区中读出，而不必担心会因为其它进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。这决定了管道通信是半双工的。  
### 线程概念和多线程模型  
1. 线程的基本概念  
引入线程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量，增加并发程度；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。  
线程最直接的理解就是“轻量级进程”。它是一个基本的CPU执行单位，也是程序执行流的最小单位，由**线程ID、程序计数器、寄存器集合和堆栈**组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。  
引入线程后，进程的内涵发生了改变，**进程只作为除CPU外的系统资源的分配单元，线程则作为处理机的分配单元**。由于一个进程内部有多个线程，若线程的切换发生在同一进程内部，则只需要很少的时空开销。  
2. 进程与线程的比较  
+ 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中进行线程切换，会引起进程切换。  
+ 拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位。而线程不拥有系统资源（仅拥有必不可少的资源），但线程可以访问其所属进程的系统资源。  
+ 并发性。在引入线程的操作系统中，不见线程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。  
+ 系统开销。

