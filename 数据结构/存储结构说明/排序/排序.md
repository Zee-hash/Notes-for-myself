# 排序  
---  
## 排序的基本概念  
### 排序的定义  
排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下：  
输入：n个记录R<sub>1</sub>，R<sub>2</sub>，···，R<sub>n</sub>，对应的关键字为k<sub>1</sub>，k<sub>2</sub>，···，k<sub>n</sub>。  
输出：输入序列的一个重排R<sub>1</sub>՛，R<sub>2</sub>՛，···，R<sub>n</sub>՛，使得k<sub>1</sub>՛≤k<sub>2</sub>՛≤···≤k<sub>n</sub>՛(或满足其它关系)。  
算法的稳定性：若待排序表中有两个元素R<sub>i</sub>，R<sub>j</sub>，其对应的关键字相同即key<sub>i</sub> = key<sub>j</sub>，且在排序前R<sub>i</sub>在R<sub>j</sub>的前面，若使用某一排序算法排序后，R<sub>i</sub>仍然在R<sub>j</sub>的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。  
在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：  
+ 内部排序，是指在排序期间元素全部存放在内存中的排序  
+ 外部排序，是指在排序期间元素无法同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序  

一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。并非所有的内部排序算法都要基于比较，事实上，基数排序就不基于比较。  
每种排序算法都有各自的优缺点，适合在不同的环境中使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。  

---  
## 插入排序  
> 每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。  

由插入排序的思想可以引申出三种排序算法：直接插入排序
折半插入排序和希尔排序。  
### 直接插入排序  
假设在排序过程中，待排序表L[1···n]在某次排序过程中的某一时刻状态如下：  

|有序序列L[1···i-1]|L(i)|无序序列L[i+1···n]|  
|---|---|---|  

要将元素L(i)插入到已有序的子序列中L[1···i-1]中，需要执行以下操作，其中L[]表示表，L()表示元素：  
+ 查找出L(i)在L[1···i-1]中的插入位置k  
+ 将L[k···i-1]中的所有元素依次后移一个位置  
+ 将L(i)复制到L(k)  

为了实现对L[1···n]的排序，可以将L(2)~L(n)依次插入到前面已排好序的子序列中，初始L[1]可视为是一个已排好序的子序列。上述操作执行n-1次就能得到一个有序的表。插入排序在实现上通常采用就地排序（空间复杂度为O(1）），因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。  
直接插入排序代码如下：  
```C
void InsertSort(ElemType A[], int n)
{
    int i, j;
    for(i = 2; i <= n; i++)
    {
        if(A[i] < A[i-1])// 小于其前驱时，才表示需要插入到有序子序列中，否则直接插入到最后
        {
            A[0] = A[i];// 复制为哨兵，A[0]不存放元素
            for(j = i-1; A[0] < A[j]; --j)
            {
                A[j+1] = A[j];// 大于哨兵的元素后移
            }
            A[j+1] = A[0];// 复制到插入位置
        }
    }
}
```  
直接插入排序算法的性能分析如下：  
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。  
时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。  
在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)。  
在最坏情况下，表中元素顺序刚好与排序结构中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大。  
平均情况下，考虑待排序表中元素是随机的，此时可取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n<sup>2</sup>/4。  
因此，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)。  
稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。  
适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。  

### 折半插入排序  
从直接插入排序算法中，每趟插入的过程中都进行了两项工作：  
+ 从前面的有序子序列中查找出待插入元素应该被插入的位置  
+ 给插入位置腾出空间，将待插入元素复制到表中的插入位置  

在该算法中，总是边比较边移动元素。  
下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法左如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下：  
```C
void InsertSort(ElemType a[], int n)
{
    int i, j, low, high, mid;
    for(i = 2; j <= n; i++)
    {
        A[0] = A[i];
        low = 1, high = i-1;// 折半查找的范围
        while(low <= high)
        {
            mid = (low + high) / 2;
            if(A[mid] > A[0])
            {
                high = mid - 1;// 查找左半子表
            }
            else
            {
                low = mid + 1;// 查找右半子表
            }
        }
        for(j = i-1; j >= high+1; --j)
        {
            A[j+1] = A[j];// 统一后移元素，空出插入位置
        }
        A[high+1] = A[0];// 插入操作
    }
}
```  
性能分析：  
折半插入排序仅减少了比较元素的次数，约为O(nlog<sub>2</sub>n)，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O(n<sup>2</sup>)，但对于数据量不大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。  

### 希尔排序  
从前面的分析可知，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)，但若待排序列为“正序”时，其时间复杂度可提高至O(n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。  
希尔排序的基本思想是：先将待排序表分割成若干形如L[i，i+d，i+2d，···，i+kd]的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。  
希尔排序的过程如下：先取一个小于n的步长d<sub>1</sub>，把表中的全部记录分为d<sub>1</sub>组，所有距离为d<sub>1</sub>的倍数的记录放在同一组，在各组内进行直接插入排序；然后取第二个步长d<sub>2</sub> < d<sub>1</sub>，重复上述过程，直到所取到的d<sub>t</sub> = 1，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是d<sub>1</sub> = n/2，d<sub>i+1</sub> = ⎣d<sub>i</sub> / 2⎦，并且最后一个增量等于1。  
希尔排序算法的代码如下：  
```C
void ShellSort(ElemType A[], int n)
{
    for(dk = n/2; dk >= 1; dk = dk / 2)
    {
        for(i = dk+1; i <= n; ++i)
        {
            if(A[i] < A[i - dk])
            {
                A[0] = A[i];// 
                for(j = i-dk; j > 0&&A[0] < A[j]; j-=dk)
                {
                    A[j+dk] = A[j];// 记录后移
                }
                A[j+dk] = A[0];
            }
        }
    }
}
```  
性能分析：  
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。  
时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，当n在某个特定范围时，希尔排序的时间复杂度约为O(n<sup>1/3</sup>)。在最坏情况下希尔排序的时间复杂度为O(n<sup>2</sup>)。  
稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。  
适用性：希尔排序算法仅适用于线性表为顺序存储的情况。（需要随机访问特性）  

---  
## 交换排序  
> 根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置  

基于交换的排序算法很多，以下主要介绍冒泡排序和快速排序。  
### 冒泡排序  
冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果就是把序列中的最小元素（或最大元素）放到了序列的最终位置······这样最多做n-1趟就能把所有元素排好序。  
冒泡排序的算法的代码如下：  
```C
void BubbleSort(ElemType A[], int n)
{
    for(i = 0; i < n-1; i++)
    {
        flag = false;// 表示本趟冒泡是否发生交换
        for(j = n-1; j > i; j--)
        {
            if(A[j-1] > A[j])
            {
                swap(A[j-1], A[j]);
                flag = true;// 发生交换
            }
        }
        // 每趟结束后判断本次是否发生交换，如未发生交换，说明元素已经有序  
        if(flag == false)
        {
            return ;
        }
    }
}
```  
性能分析：  
空间效率：仅使用了常数个辅助单位，因而空间复杂度为O(1)。  
时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false，从而直接跳出循环，比较次数为n-1次，移动次数为0，从而最好情况下的时间复杂度为O(n)；当初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的的比较，而且每次比较后都必须移动元素3次来交换元素位置。这种情况下：  
比较次数 = n(n-1)/2  
移动次数 = 3n(n-1)/2  
从而，最坏情况下的时间复杂度为O(n<sup>2</sup>)，其平均时间复杂度也为O(n<sup>2</sup>)。  
稳定性：由于i>j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。  
冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于或大于无须子序列中所有元素的关键字，这样每趟排序都会把一个元素放置到其最终位置上。  

### 快速排序  
快速排序的思想是基于分治法的：在待排序表L[1···n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1···k-1]和L[k+1···n]，使得L[1···k-1]中的所有元素小于pivot，L[k+1···n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直到每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。  
一趟快速排序的过程是一个交替搜索和交换的过程。  
假设划分算法已知，记为Partition()，返回的是上述的k，注意到L(k)已在最终的位置，因此可以先对表进行划分，而后对两个表调用相同的排序操作。因此可以递归地调用快速排序算法进行排序，具体的程序结构如下：  
```C
void QuickSort(ElemType A[], int low, int high)
{
    if(low < high)// 递归结束条件
    {
        int pivotpos = Partition(A, low, high);// 划分
        QuickSort(A, low, pivotpos-1);
        QuickSort(A, pivot+1, high);
    }
}
```  
快速排序算法的关键在于划分操作，同时快速排序算法的性能也主要取决于划分操作的好坏。假设每次总以当前表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，使得一趟Partition()操作后，表中的元素被枢轴一分为二。代码如下：  
```C
int Partition(ElemType A[], int low, int high)
{
    ElemType pivot = A[low];// 将当前表中第一个元素设为枢轴，对表进行划分
    while(low < high)
    {
        while(low < high && A[high] >= pivot)
        {
            --high;
        }
        // 找到一个比枢轴小的，放到low所在的位置
        A[low] = A[high];
        While(low < high && A[low] <= pivot)
        {
            ++low;
        }
        // 找到一个比枢轴大的，放到high所在的位置
        A[high] = A[low];
    }
    A[low] = pivot;// 枢轴元素存放到最终位置
    return low;// 返回存放枢轴的最终位置，用于划分子表
}
```  
性能分析：  
空间效率：由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。最好情况下为O(log<sub>2</sub>n)；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；平均情况下，栈的深度为O(log<sub>2</sub>n)。  
时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(n<sup>2</sup>)。  
又很多算法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。  
在最理想的状态下，即Partition()可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n/2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为O(nlog<sub>2</sub>n)。好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。**快速排序是所有内部排序算法中平均性能最优的排序算法。**  
稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。  
在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准）元素放到其最终的位置上。  

---  
## 选择排序  
> 每一趟（如第i趟）在后面n-i+1(i = 1,2,···,n-1)个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完  

### 简单选择排序  
假设排序表为L[1···n]，第i趟排序即从L[i···n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。  
简单选择排序算法的代码如下：  
```C
void SelectSort(ElemType A[], int n)
{
    for(i = 0; i < n-1; i++)
    {
        min = i;// 记录每趟最小元素的位置
        for(j = i+1; j < n; j++)
        {
            if(A[j] < A[min])
            {
                min = j;// 记录新的最小的元素的位置
            }
        }
        if(min != i)// 最小值位置发生变更
        {
            swap(A[i], A[min]);
        }
    }
}
```  
性能分析：  
空间效率：仅适用常数个辅助单元，故空间效率为O(1)。  
时间效率：在简单选择排序过程中，元素移动的操作次数很少，不会超过3(n-1)次（即n-1次交换操作），最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是n(n-1)/2，因此时间复杂度始终是O(n<sup>2</sup>)。  
稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会**导致第i个元素与其含有相同关键字的元素的相对位置发生改变**。因此，简单选择排序是一种不稳定的排序方法。  

### 堆排序