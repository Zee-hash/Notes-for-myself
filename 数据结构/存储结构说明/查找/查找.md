# 查找  
---  
## 查找的基本概念  
+ 查找  
  在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。  
+ 查找表（查找结构）  
  用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数据或链表等数据类型。对于查找表经常进行的操作一般有4种：  
  ① 查询某个特定的数据元素是否在查找表中  
  ② 检索满足条件的某个特定的数据元素的各种属性  
  ③ 在查找表中插入一个数据元素  
  ④ 从查找表中删除某个数据元素  
+ 静态查找表  
  若一个查找表的操作只涉及上述操作①和②，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态的插图或删除的查找表称为动态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。二叉平衡树和B树都是二叉排序树的改进。  
+ 关键字  
  数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。  
+ 平均查找长度  
  在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为  
  ASL = P<sub>1</sub>C<sub>1</sub> + ··· + P<sub>i</sub>C<sub>i</sub> + ··· + P<sub>n</sub>C<sub>n</sub>  
  式中，n是查找表的长度；P<sub>i</sub>是查找到第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即P<sub>i</sub> = 1/n；C<sub>i</sub>是找到第i个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。 

---  
## 顺序查找和折半查找  
### 顺序查找  
> 顺序查找又称线性查找，主要用于在线性表中查找。顺序查找通常分为对一般线性表的顺序查找和对按关键字有序的顺序表的顺序查找。  

#### 一般线性表的顺序查找  
作为一种最直观的查找方法，其基本思想都是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。  
```C
typedef struct// 查找表的数据结构
{
  ElemType *elem;// 元素存储空间的基址，建表时按实际长度分配，0号单元留空
  int TableLen;// 表的长度
}SSTable;
int Search_Seq(SSTable ST, ElemType key)
{
  ST.elem[0] = key;// “哨兵”
  for(i = ST.TableLen; ST.elem[i] != key; --i)
  {
    // 空，从前往后找
  }
  return i;// 若表中不存在关键字为key的元素，将查找到i为0时推出for循环
}
```  
在上述算法中，将ST.elem[0]称为哨兵。引入它的目的是使得Search_Seq内的循环不必判断数组数组是否越界，因为满足i==0时，循环一定会跳出。**引入哨兵可以避免很多不必要的判断语句**，从而提高程序效率。  
对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需进行n-i+1次关键字的比较，即C<sub>i</sub> = n-i+1。查找成功时，顺序查找的平均长度为  
*ASL<sub>成功</sub> = P<sub>1</sub> × n + P<sub>2</sub> × (n-1) + ··· + P<sub>i</sub> × (n-i+1) + ··· + P<sub>n</sub>× 1*  
当每个元素的查找概率相等时，即p<sub>i</sub> = 1/n 时，**ASL<sub>成功</sub> = (n+1) / 2。**  
查找不成功时，与表中各关键字的比较次数显然是n+1次，从而顺序查找不成功的平均查找长度为**ASL<sub>不成功</sub> = n + 1。**  
通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，是表中记录按查找概率由小到大重新排列。  
综上所述，顺序查找的缺点是当n较大时，平均查找长度较大，效率低；优先是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。**对线性的链表只能进行顺序查找**。  

#### 有序表的顺序查找  
若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。  
假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找的元素的关键字为key，当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，这时就可返回查找失败的信息，因为第i个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。  
可用判定树来描述有序顺序表的查找过程。树中的圆形结点表示有序顺序表中存在的元素；树中的矩形结点称为失败结点（若有n个结点，则相应地有n+1个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到失败结点，则说明查找不成功。  
在有序表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找失败的平均查找长度在相等查找概率的情形下为  
ASL<sub>不成功</sub> = n / 2 + n / (n + 1)  
注意，有序表的顺序查找和折半查找的思想是不一样的，且有序表的顺序查找中的线性表可以是链式存储结构。  

### 折半查找  
折半查找又称二分查找，**它仅适用于有序的顺序表**。  
折半查找的基本思想：首先将给定值key与表中中间位置的元素进行比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。算法如下：  
```C
int Binary_Search(SeqList L, ElemType key)
{
  int low = 0, high = L.TableLen - 1, mid;  
  while(low < high)
  {
    mid = (low + high) / 2;// 取中间位置
    if(L.elem[mid] == key)
    {
      return mid;// 查找成功返回则返回所在位置
    }
    else if (L.elem[mid] > key)
    {
      high = mid - 1;// 从前半部分继续查找
    }
    else
    {
      low = mid + 1;// 从后半部分继续查找
    }
  }
  return -1;// 查找失败
}
```  
折半查找的过程可用二叉树来描述，称为判定数。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找不成功时的查找长度为从根结点到对应失败结点的父节点的路径上的结点数；每个结点值均大于其左子结点值，且均小于其右子结点值。若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点。显然，判定树是一棵平衡二叉树。  
由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为  
ASL = (n + 1) / n × log<sub>2</sub>(n + 1) - 1 ≈ log<sub>2</sub>(n + 1) - 1  
设h为树的高度，则元素个数为n时树高h = ⎡log<sub>2</sub>(n + 1)⎤。所以，折半查找的时间复杂度为O(log<sub>2</sub>n)，平均情况下比顺序查找的效率高。  
因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法**仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列**。  

### 分块查找  
分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。  
分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。  
分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找。  
分块查找的平均查找长度为索引查找和块内查找的平均查找长度之和。设索引块和块内查找的平均查找长度分别为L<sub>I</sub>、L<sub>S</sub>，则分块查找的平均查找长度为  
ASL = L<sub>I</sub> + L<sub>S</sub>  
将长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为  
ASL = L<sub>I</sub> + L<sub>S</sub> = (b + 1) / 2 + (s + 1) / 2 = (s<sup>2</sup> + 2s + n) / 2s  
此时，若s = √n，则平均查找长度取最小值√n + 1；若对索引表采用折半查找时，则平均查找长度为  
ASL = L<sub>I</sub> + L<sub>S</sub> = ⎡log<sub>2</sub>(b + 1)⎤ + (s + 1) / 2  