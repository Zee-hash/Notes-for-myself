## 外部排序  
### 外部排序的基本概念  
内部排序都是在内存中进行的。而在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再将数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序。  

### 外部排序的方法  
文件通常是按块存储在磁盘上的，操作系统也是按对磁盘上的信息进行读写的。因为磁盘读/写的机械动作所需的时间远远超过内存运算的时间，因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I/O次数。  
外部排序通常采用归并排序法。它包括两个相对独立的阶段：  
① 根据内存缓冲区的大小，将外存上的文件分为若干长度为𝓁的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子序列重新写回外存，称这些有序子文件为归并段或顺串。  
② 对这些归并段进行逐趟排序，使归并段（有序子文件）逐渐由小到大，直到得到整个有序文件为止。  
将内存工作区等分为3个缓冲区，其中的两个为输入缓冲区，一个为输出缓冲区。首先，从两个输入归并段R1和R2中分别读入一个块，放在输入缓冲区1和输入缓冲区2中。然后，在内存中进行2路归并，归并后的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段R1՛中，再清空输出缓冲区，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当R1和R2归并完成后，在归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上趟的结果R1՛和R2՛、R3՛和R4՛两两归并，这又是一趟归并、最后把R1՛՛和R2՛՛两个归并段归并，结果得到最终的有序文件，一共进行了3趟归并。  
在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果段同时存放在内存中，因此需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：  
外部排序的总时间 = 内部排序所需的时间 + 外存信息读写的时间 + 内部归并所需的时间  
显然，外存信息读写的时间远大于内部排序和内部归并的时间，因此因着力减少I/O次数。由于外存信息的读/写是以“磁盘块”为单位的，可知每一趟归并需进行16次读和16次写，3趟归并加上内部排序时所需进行的读/写，使得总共需进行32×3+32=128次读写。  
若改用4路归并排序，则只需2趟归并，外部排序时的总读/写次数便减至32×2+32=96次。**因此，增加归并路数，可减少归并趟数，进而减少总的磁盘I/O次数。**  
一般地，对r个初始归并段，做k路平衡归并，归并树可用严格k叉树（即只有度为k与度为0的结点的k叉树）来表示。第一趟可将r个初始归并段归并为⎡r/k⎤个归并段，以后每趟归并将m个归并段归并成⎡m/k⎤个归并段，直至最后形成一个大的归并段为止。树的高度 = ⎡log<sub>k</sub>r⎤ = 归并趟数S。可见，只要增大归并路数k，或减少初始归并段个数r，都能减少归并趟数S，进而减少读写磁盘的次数，达到提高外部排序速度的目的。  

### 多路平衡归并与败者树  
增加归并路数能减少归并趟数，进而减少I/O次数。然而，增加归并路数k时，内部归并的时间将增加。做内部归并时，在k个元素中选择关键字最小的记录需要比较k-1次。每趟归并n个元素需要做(n-1)(k-1)次比较，S趟归并总共需要的比较次数为  
S(n-1)(k-1) = ⎡log<sub>k</sub>r⎤(n-1)(k-1) = ⎡log<sub>2</sub>2⎤(n-1)](k-1)/⎡log<sub>2</sub>k⎤  
式中，(k-1)/⎡log<sub>2</sub>k⎤随k的增长而增长，因此内部归并时间亦随k的增长而增长。这将抵消由于增大k而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。  
为了使内部归并不受k的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录。内部结点用来记忆左右子树中的“失败者”，而让胜者一直往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的树为最小数。  
因为k路归并的败者树深度为⎡log<sub>2</sub>k⎤，因此k个记录中选择最小的关键字，最多只需要⎡log<sub>2</sub>k⎤次比较。所以总的比较次数为  
S(n-1)⎡log<sub>2</sub>k⎤ = ⎡log<sub>k</sub>r⎤(n-1)⎡log<sub>2</sub>k⎤ = (n-1)/⎡log<sub>2</sub>r⎤  
可见，使用败者树后，内部归并的比较次数与k无关了。因此，只要内存空间允许，增大归并路数k将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。  
归并路数k并不是越大越好。归并路数k增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当k值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加。  

### 置换-选择排序（生成初始归并段）  
减少初始归并段个数r也可以减少归并趟数S。若总的记录个数为n，每个归并段的长度为𝓁，则归并段的个数为r = ⎡n/𝓁⎤。采用内部排序方法得到的各个初始归并段长度都相同（出最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，采用置换-选择算法来产生更长的初始归并段。  
设初始待排文件为FI，初始归并段输出文件到FO，内存工作区为WA，FO和WA的初始状态为空，WA克容量w个记录。置换-选择算法的步骤如下：  
1. 从FI输入w个记录到工作区WA。  
2. 从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。  
3. 将MINMAX中记录输出到FO中去。  
4. 若FI不空，则从FI输入下一个记录到WA中。  
5. 从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。  
6. 重复3-5，直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。  
7. 重复2-6，直至WA为空。由此得到全部初始归并段。  

上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。  

### 最佳归并树  
文件经过置换-选择排序后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等的初始归并段的归并顺序，使得I/O次数最少。  
显然，归并方案不同，所得归并树亦不同，树的带权路径长度（I/O次数）亦不同。为了优化归并树的WPL，可将哈弗曼树的思想推广到m叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树。  
**若初始归并段不足以构成一棵严格k叉树时，需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。**  
如何判定添加虚段的数目？  
设度为0的结点有n<sub>0</sub>(=n)个，度为k的结点有n<sub>k</sub>个，则对严格k叉树有n<sub>0</sub> = (k-1)n<sub>k</sub> + 1，由此可得n<sub>k</sub> = (n<sub>0</sub>-1)/(k-1)。  
+ 若(n<sub>0</sub>-1)/(k-1) = 0（%为取余运算），则说明这n<sub>0</sub>个叶结点（初始归并段）正好可以构造k叉归并树。此时，内结点有n<sub>k</sub>个。  
+ 若(n<sub>0</sub>-1)/(k-1) = u ≠ 0，则说明对于这n<sub>0</sub>个叶结点，其中有u个多余，不能包含在k叉归并树中。为构造包含所有n<sub>0</sub>个初始归并段的k叉归并树，应在原有n<sub>k</sub>个内结点的基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被替代的叶结点加上刚才多出的u个叶结点，即再加上k-u-1个空归并段，就可以建立归并树。