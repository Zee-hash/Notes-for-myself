# 数据的表示和运算  
---  
## 数制和编码  
### 进位计数制及其相互转换  
在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点：  
+ 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制的每一位，制造成本比较低。  
+ 二进制1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中逻辑判断提供了便利条件。  
+ 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。  

#### 进位计数法  
在进位计数法中，每个数位所用到的不同数码的个数称为基数。  
每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。  
一个进位数的数值大小就是它的各位数码按权相加。  
+ 二进制  
+ 八进制
+ 十六进制  
#### 不同进制数之间的相互转换  
+ 二进制数转换为八进制数和十六进制数  
以小数点为界，其整数部分，从小数点开始往左数，将一串二进制分为3位（八进制）一组或4位（十六进制）一组，在数的最左边可根据需要加“0”补齐。对于小数部分，从小数点开始往右数，也将一串二进制分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为3或4的整数倍，然后分别用对于的八进制数或十六进制数取代。  
+ 任意进制数转换为十六进制数  
将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。  
+ 十进制数转换为任意进制数  
一个十进制数转换为任意进制数，常采用基数乘除法。这种转换方法对十进制的整数部分和小数部分分别进行处理，对整数部分采用除基取余法，对小数部分用乘基取整法，最后将整数部分和小数部分的转换结果拼接起来。  
除基取余法：整数部分除基取余，最先取得的余数为数的最低位，最后取得的位为数的最高位，商为0时结束。  
乘基取整法：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位。乘积为1.0（或满足精度要求）时结束。  

### 真值和机器数  
在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码和反码表示法。这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。
真值是机器数所代表的实际值。 

### BCD码  
二进制编码的十进制数（Binary-Coded Decimal,BCD）通常采用4位二进制来表示一位十进制数中的0~9这10个数码。这种编码方式使得二进制数与十进制数之间的转换得以快速进行。但4位二进制数可以组合出16种代码，因此必有6种状态为冗余状态。  
#### 8421码  
它是一种有权码，设其各位的数值为b3,b2,b1,b0，则权值从高到低依次是8,4,2,1。  
若两个8421码相加之和小于1001，则不需要修正；若相加之和大于等于1010，则需要加6修正，并向高位进位，进位可以在首次相加或修正时产生。  
#### 余3码  
它是一种无权码，是在8421码的基础上加0011形成的，因此每个数都多余3，因此成为余3码。  
#### 2421码  
它是一种有权码，权值由高到低分别是2,4,2,1，特点是大于等于5的4位二进制数中最高位为1，小于5的最高位为0。  

### 字符与字符串  
由于计算机内部只能识别和处理二进制代码，所以字符都必须按照一定的规则用一组二进制编码来表示。  
#### 字符编码ASCII码  
目前，国际上普遍采用一种字符系统是7位二进制编码的ASCII码，它可以表示10个十进制数码、52个大小写英文字母及一定数量的专用符号，共128个字符。  
在ASCII码中，编码值0~31为控制字符，用于通信控制或设备的功能控制；编码值127是DEL码；编码值32是空格SP；编码值32~126共95个字符称为可印刷字符。  
**0~9的编码值为0110 0000~0110 1001**  
#### 汉字的表示和编码  
在1981年的国家标准GB2312-1980中，每个编码用两个字节表示，收录了一级汉字3755个、二级汉字3008个、各种符号682个，共计7445个。  
目前最新的汉字编码是2000年公布的国家标准GB18030，它收录了汉字27484个汉字。编码标准采用1B、2B和4B。  
汉字的编码包括汉字的输入编码、汉字内码、汉字字形码三种，它们是计算机中用于输入、内部处理和输出用途的编码。区位码是国家标准局于1981年颁布的标准，它用两字节表示一个汉字，每字节用七位码，并将汉字和图形符号排列在一个94*94的二维代码表中。区位码是4位十进制数，前两位是区码，后两位是位码，所以称为区位码。  
国标码将十进制的区位码转换为十六进制数后，再在每个字节上加上20H。国标码两字节的最高位都是0，ASCII码的最高位也是0.为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改成1，这就是汉字内码。  
区位码和国标码都是输入码。  

### 校验码  
校验码是指能够发现或自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来校验或纠错编码。  
通常某种编码都由许多码字构成，任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。对于码距不小于2的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力就越强，而且检错能力总是大于纠错能力。  
#### 奇偶校验码  
在原编码上加上一个校验位，它的码距为2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误，增加的冗余位称为奇偶校验位。  
奇偶校验实现的方法：由若干位有效信息再加上一个二进制位（校验位）组成校验码。校验位的取值将使整个校验码中“1”或“0”的个数为奇数或偶数，所以有两种可供选择的校验规律。  
奇校验码：整个校验码中“1”的个数为奇数。
偶校验码：整个校验码中“1”的个数为偶数。  
#### 海明校验码  
海明码是广泛采用的一种有效的校验码，它实际上是一种多重奇偶校验码。其实现原理是在有效信息位从加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。  
**根据纠错理论得：L - 1 = D + C 且 D >= C**  
即编码最小码距L越大，其检测错误的位数D越大。纠正错误的位数C也越大，且纠错能力恒小于检错能力。  
#### 循环冗余检验CRC码  
CRC的基本思想是：在K为信息码后再拼接R位的校验码，整个编码的长度为N位，因此，这种编码又称(K,N)码。  
CRC码基于线性编码理论，在发送端，将要传送的K位二进制信息码左移R位，将它与生成多项式做**模2除法**，生成一个R位校验码，并附在信息码后，构成一个新的二进制码（CRC码），共K+R位。在接收端，利用生成多项式对接收到的编码做模2除法，以检测和确定出错的位置，如无错则整除，其中生成多项式是接收端和发送端的一个约定。  
任意一个二进制数码都可用一个系数仅为“0”和“1”的多项式与其对应。生成多项式G(x)的最高次幂为R，转换成对应的二进制数有R+1位。  

--- 
## 定点数的表示和运算  
### 定点数的表示  
#### 有符号数的表示  
在计算机中参与运算的机器数有两大类：无符号数和有符号数  
+ 无符号数。整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。  
+ 有符号数。在机器中，数的正负号是无法识别的，有符号数用“0”
表示正号，用“1”表示负号，从而将负号也数值化。并通常约定二进制的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。  

有符号数的机器表示有原码、补码、反码和移码。  
#### 机器数的定点表示  
根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。  
定点表示即约定机器数中小数点的位置是固定不变的，小数点不再使用“.”表示，而是约定它的位置。在计算机中有两种简单的约定：将小数点的位置固定在数据的最高位之前，或固定在最低位之后。一般称前者为定点小数，后者为定点整数。  
+ 定点小数  
定点小数是纯小数，约定小数点的位置在符号位之后，有效数值部分最高位之前。  
+ 定点整数  
定点整数是纯整数，约定小数点位置在有效数值部分最低位的最后。  
#### 原码、补码、反码、移码  
+ 原码表示法  
原码是一种比较简单、直观的机器数表示法，用机器数的最高位表示该数的符号，其余的各位表示数的绝对值。  
**真值零的原码表示有正0和负0两种形式。**  
+ 补码表示法  
对于两个不同符号数的加法（或同符号数的减法），先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要给结果选择合适的符号。而补码表示法中的加减法则统一采用加法操作实现。  
**真值零的补码是唯一的。**  
+ 反码表示法  
反码通常用来作为由原码求补码或由补码求原码的中间过渡。  
**真值零的反码表示不唯一**  
+ 移码表示法  
移码通常用来表示浮点数的阶码。它只能用来表示整数。  
移码就是在真值X上加上一个常数（偏置值），通常这个常数取2<sup>n</sup>，相当于X在数轴上向正方向偏移了若干个单位。  
移码具有以下特点：  
  - 移码中零的表示唯一  
  - 一个真值的移码和补码仅差一个符号位  
  - 移码全0时，对应真值的最小值；移码全1时，对应真值的最大值  
  - 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小  


+ 由原码求补码、补码求原码  
对于正数，补码和原码的表示相同  
对于负数，原码符号位不变，数值部分按位取反，末位加1，此规则也可用于由补码求原码。  

### 定点数的运算  
#### 定点数的移位运算
移位运算根据操作对象的不同分为算术移位和逻辑移位。有符号位的移位称为算术移位，逻辑移位的操作对象是逻辑代码，可视为无符号数。  
+ 算术移位  
算术移位的对象是符号位，在移位的过程中符号位保持不变。  
对于正数，移位后出现的空位以0补全。对于负数，由于原码、补码和反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同。对应的规则为原码补0，反码补1。补码右移补1，左移补0。  
+ 逻辑移位  
逻辑移位将操作数视为无符号数，移位规则：逻辑左移时，低位补0；逻辑右移时，高位补0。  
+ 循环移位  
循环移位分为带进位标志位CF的循环移位（大循环）和不带进位标志位循环移位（小循环）。  
循环移位的主要特点是，移出的位又被移入数据中，而是否带进位则要看是否将进位标志位加入循环位移。循环移位操作特别适合将数据的低字节数据和高字节数据互换。  
#### 原码定点数的加减法运算  
加法规则：先判符号位，若相同，则绝对值相加，结果符号位不变；若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。  
减法规则：两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号位取反后的减数按原码加法进行运算。  
**运算时要注意机器字长，当左边位出现溢出时，将溢出位丢掉。**  
#### 补码定点数加减法运算  
补码加减运算规则简单，易于实现，因此计算机系统中普遍采用补码加减运算。补码运算的特点如下（设机器字长为n+1）  
+ 参与运算的两个操作数均用补码表示  
+ 按二进制运算规则运算，逢二进一  
+ 符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出  
+ 补码加减运算依据下面的公式进行。当参与运算的数是定点小数时，模M=2；当参与运算的数是定点整数时，模M=2<sup>n+1</sup>。  
  [A+B]<sub>补</sub> = [A]<sub>补</sub>+[B]<sub>补</sub>(mod M)  
  [A-B]<sub>补</sub> = [A]<sub>补</sub>+[-B]<sub>补</sub>(mod M)  
  mod M运算是为了将溢出位丢掉  
+ 补码运算的结果仍然是补码  
#### 符号扩展  
在计算机算术运算中，有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。例如，某个程序需要将一个8位数与另外一个32位数相加，要想得到正确的结果，在将8位数与32位数相加之前，必须将8位数转换成32位数形式，这称为“符号扩展”。  
正数扩展即原有的符号位移到新形式的符号位上，新表示形式的所有附加位都用0进行填充。  
负数的符号扩展方法则根据机器数的不同而不同。原码表示负数的符号扩展方法与正数相同，只不过此时符号位为1。补码表示负数的符号扩展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1（对于整数）或0（对于小数）进行填充。反码表示负数的符号扩展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1进行填充。  
#### 溢出概念和判别方法  
溢出是指运算结果超出了数的表示范围。通常，称大于机器所能表示的最大正数为上溢，称小于机器所能表示的最小负数为下溢。定点小数的表示范围为|x|<1。  
仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出。定点数加减运算出现溢出时，运算结果是错误的。  
补码定点数加减运算溢出判断的方法有3种：  
+ 采用一位符号位  
+ 采用双符号位  
+ 采用一位符号位根据数据位的进位情况判断溢出  
#### 定点数的乘法运算  
在计算机中，乘法运算是由累加和右移操作实现。根据机器数的不同，可分为原码一位乘法和补码一位乘法。  
1. 原码一位乘法  
原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位异或形成，而乘积的数值部分则是两个数的绝对值相乘之积。  
设[X]<sub>原</sub>=x<sub>s</sub>x<sub>1</sub>x<sub>2</sub>···x<sub>n</sub>，[Y]<sub>原</sub>=y<sub>s</sub>y<sub>1</sub>y<sub>2</sub>···y<sub>n</sub>，则运算规则如下：  

+ 被乘数和乘数均取绝对值参加运算，符号位为x<sub>s</sub>⊕y<sub>s</sub>
+ 部分积的长度同被乘数，取n+1位，以便存放乘法过程中绝对值大于等于1的值，初值为0
+ 从乘数的最低位y<sub>n</sub>开始判断：若y<sub>n</sub>=1，则部分积加上被乘数|x|，然后右移一位；若y<sub>n</sub>=0,则部分积加上0，然后右移一位  
+ 重复上一步，判断n次  
由于乘积的数值部分是两数绝对值相乘的结果，因此原码一位乘法运算过程中的右移操作均为逻辑右移。  
**考虑到运算时可能出现绝对值大于1的情况（但此刻并非溢出），所以部分积和被乘数取双符号位。**  
2. 补码一位乘法(Booth算法)  
有符号位的乘法，采用相加和相减操作计算补码数据的乘积。  
设[X]<sub>补</sub>=x<sub>s</sub>x<sub>1</sub>x<sub>2</sub>···x<sub>n</sub>，[Y]<sub>补</sub>=y<sub>s</sub>y<sub>1</sub>y<sub>2</sub>···y<sub>n</sub>，则运算规则如下：  
+ 符号位参与运算，运算的数均以补码表示  
+ 被乘数一般取双符号位参与运算，部分积取双符号位，初值为0,乘数可取单符号位。  
+ 乘数末尾增设附加位y<sub>n+1</sub>，但初值为0  
+ 根据(y<sub>n</sub>,y<sub>n+1</sub>)的取值来确定操作  
+ 移位按照补码右移规则进行  
+ 按照上述算法进行n+1步操作，但第n+1步不再移位(共进行n+1次累加和n次右移)，仅根据y<sub>n</sub>和y<sub>n+1</sub>的比较结果做相应的运算  
**Booth算法的移位规则**  

| y<sub>n</sub>高位 | y<sub>n+1</sub>低位 | 操作 |
| ------ | ------ | ------ |
| 0 | 0 | 部分积右移一位 |
| 0 | 1 | 部分积加[x]<sub>补</sub>，右移一位 |  
| 1 | 0 | 部分积加[-x]<sub>补</sub>，右移一位 |  
| 1 | 1 | 部分积右移一位 |  
#### 定点数的除法运算  
在计算机中，除法运算可转换成“累加——左移”（逻辑左移），根据机器数的不同，可分为原码除法和补码除法。  
1. 原码除法运算（不恢复余数法）  
原码除法主要采用原码不恢复余数法，也成原码加减交替除法。特点是商符与商值是分开进行的，商符由两个操作数的符号位“异或”形成。求商值的规则如下：  
设[X]<sub>原</sub>=x<sub>s</sub>x<sub>1</sub>x<sub>2</sub>···x<sub>n</sub>，[Y]<sub>原</sub>=y<sub>s</sub>y<sub>1</sub>y<sub>2</sub>···y<sub>n</sub>，则：  
+ 商的符号：Q<sub>s</sub>=x<sub>s</sub>⊕y<sub>s</sub>  
+ 商的数值：|Q|=|X|/|Y|  
  求|Q|的不恢复余数法运算规则如下：  
+ 符号位不参与运算  
+ 先用被除数减去除数（|X|-|Y|=|X|+(-|Y|)=|X|+[-Y]<sub>补</sub>)，当余数为正时，商为1,余数和商左移一位，再减去除数；当余数为负时，商上0，余数和商左移一位，再加上除数  
+ 当第n+1步余数为负时，需要加上|Y|得到第n+1步正确的余数（余数与被除数同号）  
2. 补码除法运算（加减交替法）  
补码一位除法的特点是，符号位和数值位一起参与运算，商符自然形成。除法第一步根据被除数和除数的符号决定是做加法还是减法；上商的原则是根据余数和除法的符号位共同决定，同号上商“1”，异号上商“0”，最后一步商恒置“1”。  
加减交替法的规则如下：  
+ 符号位参与运算，除数与被除数均用补码表示，商和余数也用补码表示  
+ 若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数  
+ 若余数与除数同号，则商上1,余数左移一位减去除数；若余数与除数异号，则商上0,余数左移一位加上除数  
+ 重复执行上一步操作n次  
+ 若对商的精度没有特殊要求，则一般采用“末位恒置1”法  

### C语言中整数类型及类型转换  
#### 有符号和无符号数的转换  
C语言允许在不同的数据类型之间做强制类型转换。强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。  
#### 不同字长整数之间的转换  
当长字长变量向短字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。  
短字长整数到长字长整数的转换，不仅要使相应的位值相等，高位还会扩展为原数字的符号位。  
### 数据的存储与排列  
#### 数据的大端方式和小端方式存储  
多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，可以分为两种排列方式：大端方式和小端方式。  
大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面。  
小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面。  
**在阅读小端方式存储的机器代码时，要注意字节是按相反顺序显示的**  
#### 数据按“边界对齐”方式存储  
假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐的方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。  
数据不按边界对齐方式存储时，可以充分利用存储空间，但半字长或字长的指令可能会存储到两个存储字中，此时需要两次访存，并且对高低字节的位置进行调整、连接之后才能得到所要的指令和数据，从而影响指令的执行效率。  
**边界对齐方式相对边界不对齐方式是一种空间换时间的思想**，因为对齐方式去指令时间相同，因此能适应指令流水。  

---  
## 浮点数的表示和运算  
### 浮点数的表示  
浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。  
#### 浮点数的表示格式  
通常，浮点数表示为N=r<sup>E</sup>×M  
其中，r是浮点数阶码的底（隐含），与尾数的基数相同，通常r=2。E和M都是有符号的定点数，E称为阶码，M称为尾数。可见浮点数由阶码和尾数两部分组成。  
**阶码是整数，阶符J<sub>f</sub>和阶码的位数m共同反映浮点数的表示范围及小数点的实际位置；数符S<sub>f</sub>代表浮点数的符号；尾数的位数n反映浮点数的精度。**  
#### 规格化浮点数  
为了提高运算的精度，必须充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值。非规格化浮点数需要进行规格化操作才能变成规格化浮点数。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。  
左规：当浮点数运算的结果为非规格化时需要进行规格化处理，将尾数算术左移一位、阶码减1（基数为2时）的方法称为左规，左规可能要进行多次。  
右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算术右移一位、阶码加1（基数为2时）的方法称为右归。需要右归时，只需要进行一次。  
规格化浮点数的尾数M的绝对值应满足条件1/r <= |M| <= 1  
若r=2，则有1/2<=|M|<=1。规格化表示的尾数形式如下：  
+ 原码规格化后  
正数为0.1××···×的形式，其最大值表示为0.11···1,最小值表示为0.100···0。尾数的表示范围为1/2~(1-2<sup>-n</sup>)  
负数为1.1××···×的形式，其最大值表示为1.10···0，最小值表示为1.11···1。尾数的表示范围为-(1-2<sup>-n</sup>)~-1/2  
+ 补码规格化后  
正数为0.1××···×的形式，其最大值表示为0.11···1,最小值表示为0.100···0。尾数的表示范围为1/2~(1-2<sup>-n</sup>)  
负数为1.0××···×的形式，其最大值表示为1.01···1,最小值表示为1.00···0。尾数的表示范围为-1~-(1/2+2<sup>-n</sup>)  
#### 浮点数的表示范围  
运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数趋于零，计算机仅将其当作机器零处理。  
#### IEEE 754标准  
按照IEEE754标准，常用的浮点数的格式  

| 类型 | 数符 | 阶码 | 尾数数值 | 总位数 | 偏置值 |  
| ----- | ----- | ----- | ----- |  ----- |  ----- |  
|短浮点数|1|8|23|32|127(0x7FH)|  
|长浮点数|1|11|52|64|1023(0x3FFH)|  
|临时浮点数|1|15|64|80|16383(0x3FFFH)|  
以短浮点数为例，最高位为数符位；其后是8位阶码，以2为底，用移码表示，阶码的偏置值为127；其后23位是原码表示的尾数数值位。对于规格化的二进制浮点数，**数值的最高位总是“1”，为了使尾数能够多表示一位有效位，将这个“1”隐含，因此尾数数值实际上是24位。隐含的“1”是一位整数。** 在浮点格式中表示的23位尾数是纯小数。  
短浮点数和长浮点数都采用隐含尾数最高数位的方法，因此可多表示一位尾数。临时浮点数又称扩展精度浮点数，无隐含位。  
IEEE754标准中，规格化的短浮点数的真值为(-1)<sup>s</sup>×1.M×2<sup>E-127</sup>　　
#### 定点、浮点表示的区别  
+ 数值的表示范围  
若定点数和浮点数的字长相同，则浮点数表示法所能表示的数值范围将远远大于定点表示法。  
+ 精度  
对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。  
+ 数的运算  
浮点数包括阶码和尾数两部分，运算时不仅需要做尾数的运算，还要做阶码的运算，而且运算的结果要求规格化，所以浮点数的运算比定点数复杂。  
+ 溢出问题  
在定点运算中，当运算结果超出数的表示范围时，发生溢出；浮点运算中，运算结果超出尾数的表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。  
### 浮点数的加减运算  
浮点数运算的特点是阶码运算和尾数运算分开进行。浮点数的加减运算一律采用补码。浮点数的运算分为以下几步：  
#### 对阶  
对阶的目的是使两个操作数的小数点的位置对齐，即使得两个数的阶码相等。为此，先求阶差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2），阶加1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度。  
#### 尾数求和  
将对阶后的尾数按照定点数相加减的运算规则进行。  
#### 规格化  
以双符号位为例，当尾数大于0时，其补码规格化形式为  
[S]<sub>补</sub>=00.1××···×  
当尾数小于0时，其补码规格化形式为  
[S]<sub>补</sub>=11.0××···×  
可见，当尾数的最高数值位与符号位不同时，即为规格化形式。规格化分为左规和右规两种。  
+ 左规：当尾数出现00.0××···×或11.1××···×时，需左规，即尾数左移1位，阶码减1，直到尾数为00.1××···×或11.0××···×。  
+ 右规：当尾数求和结果溢出（如尾数为10.××···×或01.××···×）时，需右归，即尾数右移一位，阶码加1。  
#### 舍入  
在对阶和右归的过程中，可能会将尾数低位丢失，引起误差，影响精度。常见的舍入方法有：“0”舍“1”入法和恒置“1”法。  
“0”舍“1”入法：在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末尾加1。这样做可能会使得尾数又溢出，此时需要再做一次右规。  
恒置“1”法：尾数右移时，不论丢掉的最高数值位是“1”还是“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大或变小的两种可能。  
#### 溢出判断  
与定点数加减法一样，浮点数加减法运算最后一步也需判断溢出。  
在浮点数规格化中已指出，当尾数之和（差）出现10.××···×或01.××···×时，并不代表溢出，只能将此数右规后，再根据阶码来判断浮点数运算结果是否溢出。  
浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例，当阶码的符号位出现“01”时，即阶码大于最大阶码时，表示上溢，进入终端处理；当阶码的符号位出现“10”时，即阶码小于最小阶码时，表示下溢，按机器零处理。  
#### C语言中的浮点数类型和类型转换  
C语言中的float和double类型分别对应IEEE 754单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数，但long double的长度和格式随编译器和处理器的不同而有所不同。  
在C语言中等式的赋值和判断中会出现强制类型转换，以char->int->long->double和float->double最为常见，从前到后范围和精度都从小到大，转换过程没有损失。  
+ int->float，虽然不会发生溢出，但int可以保留32位，float保留24位，可能有数据舍入  
+ int/float->double，因为double的有效位数更多，因此能够保留精确值  
+ double->float，因为float表示范围更小，因此可能发生溢出。此外，由于有效位数变少，因此可能被舍入  
+ float/double->int，因为int没有小数部分，所以数据可能会向0方向被截断（仅保留整数部分），影响精度。另外，由于int的表示范围更小，因此可能发生溢出  

---  
