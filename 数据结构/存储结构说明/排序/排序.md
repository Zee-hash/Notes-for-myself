# 排序  
---  
## 排序的基本概念  
### 排序的定义  
排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下：  
输入：n个记录R<sub>1</sub>，R<sub>2</sub>，···，R<sub>n</sub>，对应的关键字为k<sub>1</sub>，k<sub>2</sub>，···，k<sub>n</sub>。  
输出：输入序列的一个重排R<sub>1</sub>՛，R<sub>2</sub>՛，···，R<sub>n</sub>՛，使得k<sub>1</sub>՛≤k<sub>2</sub>՛≤···≤k<sub>n</sub>՛(或满足其它关系)。  
算法的稳定性：若待排序表中有两个元素R<sub>i</sub>，R<sub>j</sub>，其对应的关键字相同即key<sub>i</sub> = key<sub>j</sub>，且在排序前R<sub>i</sub>在R<sub>j</sub>的前面，若使用某一排序算法排序后，R<sub>i</sub>仍然在R<sub>j</sub>的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。  
在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：  
+ 内部排序，是指在排序期间元素全部存放在内存中的排序  
+ 外部排序，是指在排序期间元素无法同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序  

一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。并非所有的内部排序算法都要基于比较，事实上，基数排序就不基于比较。  
每种排序算法都有各自的优缺点，适合在不同的环境中使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。  

---  
## 插入排序  
> 每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。  

由插入排序的思想可以引申出三种排序算法：直接插入排序
折半插入排序和希尔排序。  
### 直接插入排序  
假设在排序过程中，待排序表L[1···n]在某次排序过程中的某一时刻状态如下：  

|有序序列L[1···i-1]|L(i)|无序序列L[i+1···n]|  
|---|---|---|  

要将元素L(i)插入到已有序的子序列中L[1···i-1]中，需要执行以下操作，其中L[]表示表，L()表示元素：  
+ 查找出L(i)在L[1···i-1]中的插入位置k  
+ 将L[k···i-1]中的所有元素依次后移一个位置  
+ 将L(i)复制到L(k)  

为了实现对L[1···n]的排序，可以将L(2)~L(n)依次插入到前面已排好序的子序列中，初始L[1]可视为是一个已排好序的子序列。上述操作执行n-1次就能得到一个有序的表。插入排序在实现上通常采用就地排序（空间复杂度为O(1）），因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。  
直接插入排序代码如下：  
```C
void InsertSort(ElemType A[], int n)
{
    int i, j;
    for(i = 2; i <= n; i++)
    {
        if(A[i] < A[i-1])// 小于其前驱时，才表示需要插入到有序子序列中，否则直接插入到最后
        {
            A[0] = A[i];// 复制为哨兵，A[0]不存放元素
            for(j = i-1; A[0] < A[j]; --j)
            {
                A[j+1] = A[j];// 大于哨兵的元素后移
            }
            A[j+1] = A[0];// 复制到插入位置
        }
    }
}
```  
直接插入排序算法的性能分析如下：  
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。  
时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。  
在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)。  
在最坏情况下，表中元素顺序刚好与排序结构中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大。  
平均情况下，考虑待排序表中元素是随机的，此时可取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n<sup>2</sup>/4。  
因此，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)。  
稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。  
适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。  

### 折半插入排序  
从直接插入排序算法中，每趟插入的过程中都进行了两项工作：  
+ 从前面的有序子序列中查找出待插入元素应该被插入的位置  
+ 给插入位置腾出空间，将待插入元素复制到表中的插入位置  

在该算法中，总是边比较边移动元素。  
下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法左如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下：  
```C
void InsertSort(ElemType a[], int n)
{
    int i, j, low, high, mid;
    for(i = 2; j <= n; i++)
    {
        A[0] = A[i];
        low = 1, high = i-1;// 折半查找的范围
        while(low <= high)
        {
            mid = (low + high) / 2;
            if(A[mid] > A[0])
            {
                high = mid - 1;// 查找左半子表
            }
            else
            {
                low = mid + 1;// 查找右半子表
            }
        }
        for(j = i-1; j >= high+1; --j)
        {
            A[j+1] = A[j];// 统一后移元素，空出插入位置
        }
        A[high+1] = A[0];// 插入操作
    }
}
```  
性能分析：  
折半插入排序仅减少了比较元素的次数，约为O(nlog<sub>2</sub>n)，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O(n<sup>2</sup>)，但对于数据量不大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。  

### 希尔排序  
从前面的分析可知，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)，但若待排序列为“正序”时，其时间复杂度可提高至O(n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。  
希尔排序的基本思想是：先将待排序表分割成若干形如L[i，i+d，i+2d，···，i+kd]的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。  
希尔排序的过程如下：先取一个小于n的步长d<sub>1</sub>，把表中的全部记录分为d<sub>1</sub>组，所有距离为d<sub>1</sub>的倍数的记录放在同一组，在各组内进行直接插入排序；然后取第二个步长d<sub>2</sub> < d<sub>1</sub>，重复上述过程，直到所取到的d<sub>t</sub> = 1，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是d<sub>1</sub> = n/2，d<sub>i+1</sub> = ⎣d<sub>i</sub> / 2⎦，并且最后一个增量等于1。  
希尔排序算法的代码如下：  
```C
void ShellSort(ElemType A[], int n)
{
    for(dk = n/2; dk >= 1; dk = dk / 2)
    {
        for(i = dk+1; i <= n; ++i)
        {
            if(A[i] < A[i - dk])
            {
                A[0] = A[i];// 
                for(j = i-dk; j > 0&&A[0] < A[j]; j-=dk)
                {
                    A[j+dk] = A[j];// 记录后移
                }
                A[j+dk] = A[0];
            }
        }
    }
}
```  
性能分析：  
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。  
时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，当n在某个特定范围时，希尔排序的时间复杂度约为O(n<sup>1/3</sup>)。在最坏情况下希尔排序的时间复杂度为O(n<sup>2</sup>)。  
稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。  
适用性：希尔排序算法仅适用于线性表为顺序存储的情况。（需要随机访问特性）