# 指令系统  
---  
## 指令格式  
指令（又称机器指令）是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是计算机的主要属性，位于硬件和软件的交界面上。  
### 指令的基本格式  
一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分：  

|操作码字段|地址码字段|  
|---|---|  

其中，操作码字段指出指令中该指令应该执行什么性质的操作和具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信心。  
地址码给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移指令、被调用的子程序的入口地址等。  
指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。**指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长**。通常，把指令长度等于机器字长的机器称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令。  
在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主存一般都是按字节编址的，所以指令字长多为字节的整数倍。  
根据指令中操作数地址码的数目的不同，可将指令分为以下几种格式。  
#### 零地址指令  

|OP|  
|---|  

只给出操作码OP，没有显式地址。这种指令有两种可能：  
+ 不需要操作数的指令，如空操作指令、停机指令、关中断指令  
+ 零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈  

#### 一地址指令  

|OP|A<sub>1</sub>|  
|---|---|  

这种指令也有两种常见的形态：  
+ 只有目的操作数的单操作数指令，按A<sub>1</sub>地址读取操作数，进行OP操作后，结果返回原地址。  
指令含义：OP（A<sub>1</sub>）-> A<sub>1</sub>  
如自增、自减、求反、求补运算  
+ 隐含约定目的地址的双操作数指令，按指令地址A<sub>1</sub>可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算的结果也将放在ACC中。
指令含义：（ACC）OP（A<sub>1</sub>） -> ACC  
若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为2<sup>24</sup>=16M  
#### 二地址指令  

|OP|A<sub>1</sub>|A<sub>2</sub>|  
|---|---|---|  

指令含义：（A<sub>1</sub>）OP（A<sub>2</sub>） -> A<sub>1</sub>  
对于常用的算术和逻辑运算，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次运算结果。  
#### 三地址指令  

|OP|A<sub>1</sub>|A<sub>2</sub>|A<sub>3</sub>  
|---|---|---|---|  

指令含义：（A<sub>1</sub>）OP（A<sub>2</sub>） -> A<sub>3</sub>  
若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令一次，取两个操作数两次，存放结果1次）  
#### 四地址指令  

|OP|A<sub>1</sub>|A<sub>2</sub>|A<sub>3</sub>|A<sub>4</sub>|  
|---|---|---|---|--|  

指令含义：（A<sub>1</sub>）OP（A<sub>2</sub>） -> A<sub>3</sub>  ，A<sub>4</sub>=下一条将要执行指令的地址  

### 定长操作码指令格式  
定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般n位操作码字段的指令系统最大能够表示2<sup>n</sup>条指令。  
定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。  
### 扩展操作码指令格式  
为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。  
最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而有所增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。  
在设计扩展操作码指令格式时，必须注意以下两点：  
+ 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同  
+ 各指令的操作码一定不能重复  

通常情况下，**对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。**  

---  
## 指令的寻址方式  
寻址方式是指寻找指令或操作数有效地址的方式，即**确定本条指令的数据地址及下一条待执行指令的地址**的方法。寻址方式分为指令寻址和数据寻址两大类。  
指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA)。  
(A)表示地址为A的数值，A即可以是寄存器编号，也可以是内存地址。对应的(A)就是寄存器中的数值或相应内存单元中的数值。EA=(A)意思是有效地址就是地址A中的数值。  
### 指令寻址和数据寻址  
寻址方式分为指令寻址和数据寻址两大类。寻找下一条将要执行的指令地址称为指令寻址；寻找操作数的地址称为数据寻址。  
#### 指令寻址  
指令寻址分为两种方式：一种是顺序寻址方式，另一种是跳跃寻址方式。  
+ 顺序寻址方式可通过程序计数器（PC）加1（一个指令字长），自动形成下一条指令的地址。  
+ 跳跃寻址通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到）和相对寻址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC值，**所以下一条指令仍然通过程序计数器PC给出**。  
#### 数据寻址  
数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。  
数据寻址的方式较多，为区别各种方式，通常在指令中设一个字段，用来指明属于哪种寻址方式，由此可得指令的格式如下所示：  

|操作码|寻址特征|形式地址A|  
|---|---|---|  

### 常见的数据寻址方式  
#### 隐含寻址　　
这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。  
隐含寻址的有限在于有利于缩短指令字长；缺点是需增加存储操作数或隐含地址的硬件。  
#### 立即寻址  
这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数。**数据采用补码形式存放**。  

|OP|#|A|  
|---|---|---|  

其中#表示立即寻址特征，A就是操作数本身。  
立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短；缺点是A的位数限制了立即数的范围。  

