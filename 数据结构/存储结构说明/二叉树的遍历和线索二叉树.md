# 二叉树的遍历和线索二叉树  
---  
## 二叉树的遍历  
> 二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。  

由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。  
由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访问顺序。**按照先遍历左子树再遍历右子树的原则**，常见的遍历次序有先序NLR、中序LNR和后序LRN三种遍历算法，**其中的“序”指的是根结点在何时被访问。**  
### 先序遍历  
先序遍历PreOrder的操作如下：  
若二叉树为空，则什么也不做；否则，  
+ 访问根结点  
+ 先序遍历左子树  
+ 先序遍历右子树  

对应的递归算法如下：  
```C
void PreOrder(BiTree T)
{
    if(T != NULL)
    {
        visit();// 访问根结点
        PreOrder(T->lchild);// 递归遍历左子树
        PreOrder(T->rchild);// 遍历右子树
    }
}
```  
### 中序遍历  
中序遍历InOrder的操作如下：  
若二叉树为空，则什么也不做；否则，  
+ 中序遍历左子树  
+ 访问根结点  
+ 中序遍历右子树  

对应的递归算法如下：  
```C
void InOrder(BiTree T)
{
    if(T != NULL)
    {
        InOrder(T->lchild);// 递归遍历左子树
        visit();// 访问根结点
        InOrder(T->rchild);// 递归遍历右子树
    }
}
```
### 后序遍历  
后序遍历PostOrder的操作过程如下：  
若二叉树为空，则什么也不做；否则，  
+ 后序遍历左子树  
+ 后序遍历右子树  
+ 访问根结点  

对应的递归算法如下：  
```C
void PostOrder(BiTree T)
{
    if(T != NULL)
    {
        PostOrder(T->lchild);// 递归遍历左子树
        PostOrder(T->rchild);// 递归遍历右子树  
        visit();// 访问根结点
    }
}
```
三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。