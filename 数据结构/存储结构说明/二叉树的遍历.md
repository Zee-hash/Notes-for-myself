# 二叉树的遍历
---   
> 二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。  

由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。  
由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访问顺序。**按照先遍历左子树再遍历右子树的原则**，常见的遍历次序有先序NLR、中序LNR和后序LRN三种遍历算法，**其中的“序”指的是根结点在何时被访问。**  
## 先序遍历  
先序遍历PreOrder的操作如下：  
若二叉树为空，则什么也不做；否则，  
+ 访问根结点  
+ 先序遍历左子树  
+ 先序遍历右子树  

对应的递归算法如下：  
```C
void PreOrder(BiTree T)
{
    if(T != NULL)
    {
        visit();// 访问根结点
        PreOrder(T->lchild);// 递归遍历左子树
        PreOrder(T->rchild);// 遍历右子树
    }
}
```  
## 中序遍历  
中序遍历InOrder的操作如下：  
若二叉树为空，则什么也不做；否则，  
+ 中序遍历左子树  
+ 访问根结点  
+ 中序遍历右子树  

对应的递归算法如下：  
```C
void InOrder(BiTree T)
{
    if(T != NULL)
    {
        InOrder(T->lchild);// 递归遍历左子树
        visit();// 访问根结点
        InOrder(T->rchild);// 递归遍历右子树
    }
}
```
## 后序遍历  
后序遍历PostOrder的操作过程如下：  
若二叉树为空，则什么也不做；否则，  
+ 后序遍历左子树  
+ 后序遍历右子树  
+ 访问根结点  

对应的递归算法如下：  
```C
void PostOrder(BiTree T)
{
    if(T != NULL)
    {
        PostOrder(T->lchild);// 递归遍历左子树
        PostOrder(T->rchild);// 递归遍历右子树  
        visit();// 访问根结点
    }
}
```
三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。  

## 递归算法和非递归算法的转换  
借助栈，分析中序遍历的访问过程：  
遍历的树为ABCDE组成的完全二叉树。  
+ 沿着根的左孩子，依次**入栈**，**直到左孩子为空**，说明已找到可以输出的结点（最左侧的结点），此时栈内元素依次为`A B D`。  
+ 栈顶元素**出栈**并访问：**若其右孩子为空，则继续执行当前步骤**；若其右孩子不空，则将右子树转执行上一步。  

栈顶D出栈并访问，它是中序序列的第一节结点；D的右孩子为空，栈顶B出栈并访问；B的右孩子不空，将其右孩子E入栈，E的左孩子为空，栈顶E出栈并访问；E的右孩子为空，栈顶A出栈并访问；A的右孩子非空，将其右孩子C入栈，C的左孩子为空，栈顶C出栈并访问。由此得到中序序列`D B E A C`。  
根据分析可以写出中序遍历的非递归算法如下：  
```C
void InOrder(BiTree T)
{
    InitStack(S);// 初始化栈
    BiTree p = T;
    while(p || !StackEmpty(S))// p不空或者栈不空的时候循环
    {
        if(p)
        {
            Push(S, p);// 当前结点入栈
            p = p -> lchild;// 左孩子不空，入栈
        }
        else
        {
            Pop(S, p);// 栈顶元素出栈
            visit(p);// 访问出栈结点
            p = p -> rchild;// 向右子树走
        }
    }
}
```

先序遍历和中序遍历的思想基本是类似的，只需把访问结点操作放在入栈操作的前面。  
先序遍历的非递归算法如下：  
```C
void InOrder(BiTree T)
{
    InitStack(S);// 初始化栈S
    BiTree p = T;// 遍历指针初始化
    while(p || !StackEmpty(S))
    {
        if(p)
        {
            visit();// 访问当前结点
            Push(S, p);// 当前结点入栈
            p = p -> lchild;// 往左子树走
        }
        else
        {
            Pop(S, p);// 出栈
            p = p -> rchild;// 向右子树走
        }
    }
}
```  
后序遍历的非递归实现是三种遍历算法中最难的。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。  
后序非递归遍历算法的思路分析：从根结点开始，将其入栈，然后沿着左子树一直向下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为如果其有右孩子，还需按相同的规则对其右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈被访问，要么右子树为空，要么右子树刚被访问完（此时左子树早已被访问完），这样就保证了正确的访问顺序。  
仍以ABCDE组成的完全二叉树为例分析：  
+ 沿着根的左孩子，依次入栈，直至左孩子为空，此时栈内元素依次为`A B D`。  
+ 读栈顶元素，若其右孩子不空且未被访问过，将右子树转执行上一步；否则，栈顶元素出栈并访问。  

栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶B的右孩子不空且未被访问过，E入栈，E的左右孩子均为空，E出栈并访问；栈顶B的右孩子不为空但被已被访问，B出栈并访问；栈顶A的右孩子不空且未被访问过，C入栈，C的左右孩子均为空，出栈并访问；栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列`D E B Ｃ A`。  
**在上述思想的第二步中，必须分清返回时是从左子树返回的还是从右子树访问的（因为要决定当前结点是否出栈并访问，前提必须是右子树为空或已被访问），因此设定一个辅助指针r，指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问**。  
后序遍历的非递归算法如下：  
```C
void PostOrder(BiTree T)
{
    InitStack(S);// 初始化栈S
    BiTree p = T;// 初始化遍历指针
    BiTree r = NULL;// 辅助指针
    while(p || !StackEmpty(S))
    {
        if(p)
        {
            push(S, p);
            p = p -> lchild;// 往左子树走
        }
        else
        {
            GetTop(S, p);// 读取栈顶元素
            if(p->rchild && p->rchild != r)
            {
                // 当前结点有右子树且未被访问过
                p = p -> rchild;// 向右子树走
                push(S, p);// 继续入栈
                p = p -> lchild;// 往左子树走
            }
            else
            {
                // 当前元素可出栈，即满足无右子树或右子树存在但右子树已被访问
                pop(S, p);// 结点出栈
                visit(p);
                r = p;// 记录当前被访问的结点，作为下一次访问的最近访问结点用作参考
                p = NULL;// 结点访问完成后，重置p指针
            }
        }// else
    }// while
}
```  
实际上，访问一个结点p的时候，栈中结点恰好是p结点的所有祖先，从栈底到栈顶结点再加上p结点，刚好构成从根结点到p结点的一条路径。在很多算法中可以利用这一思路来求解，如求根到某结点的路径，求两个结点的最近公共祖先等。  

## 层次遍历  
要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，再将其右子树根结点入队。然后出队，访问出队结点······如此反复，直至队列为空。  
二叉树的层次遍历算法如下：  
```C
void LevelOrder(BiTree T)
{
    InitQueue(Q);// 初始化队列  
    BiTree p = NULL;// 初始化遍历指针
    EnQueue(Q, T);// 根结点入队
    while(!QueueEmpty(Q))
    {
        DeQueue(Q, p);// 出队
        visit();
        if(p->lchild)
        {
            EnQueue(Q, p->lchild);// 左子树不空，则左孩子入队
        }
        if(p->rchild)
        {
            EnQueue(Q, p->rchild);// 右子树不空，则右孩子入队
        }
    }
}
```  
**遍历是二叉树各种操作的基础，可以在遍历的过程中对结点进行各种操作，例如，对于一棵已知树求结点的双亲、求结点的孩子结点、求二叉树的深度、求二叉树的叶子结点数、判断两棵二叉树是否相同等。所以的这些操作都建立在二叉树遍历的基础上。**  

## 由遍历构造二叉树  
+ 由二叉树的先序遍历和中序遍历可以唯一的确定一棵二叉树。  
在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个字序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归下去，便能唯一地确定这棵二叉树。  
+ 同理，由二叉树的后序序列和中序序列也可以唯一地确定一颗二叉树。  
  因为后序序列的最后一个结点就如同先序序列的第一个结点。可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。  
+ 由二叉树的层序序列和中序序列也可唯一地确定一棵二叉树。  
+ 若只知道二叉树的先序序列和后序序列，则无法唯一确定一棵二叉树。  