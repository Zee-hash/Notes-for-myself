# 串的模式匹配  
---  
## 简单的模式匹配算法  
> 子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。  

以下是采用定长顺序存储结构的字符串，一种不依赖于其他串操作的暴力匹配算法。  
```C
int Index(SString S, SString T)
{
    int i = 1, j = 1;
    while((i<=S.length) && (j<=T.length))
    {
        if(S.ch[i]==T.ch[j])
        {
            // 继续比较后继字符串
            ++i;
            ++j;
        }
        else
        {
            // i返回到此次匹配位置开始的下一个位置，重新开始匹配
            i = i - j + 2;
            j = 1;
        }
    }
    if(j>T.length)
    {
        // 匹配成功
        return i-T.length;
    }
    else
    {
        // i>S.length
        return 0;
    }
}
```
在上述算法中，分别用计数指针i和j指示主串S和模式串T中当前正待比较的字符位置。算法思想为：从主串S的第一个字符起，与模式串T的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为0。  
暴力模式匹配的最坏时间复杂度为O(nm)，其中n和m分别为主串和模式串的长度。  

---  
## 改进的模式匹配算法——KMP算法  
> 在暴力匹配中，每趟匹配失败都是模式后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行子我比较，这就是其低效率的根源。因此，可以从分析模式本身的结构着手，如果已匹配相等的前缀序列中有某个后缀正好是模式的前缀，那么就可以将模式向后滑动到与这些相等字符对齐的位置，主串i指针无须回溯，并继续从该位置开始进行比较。而模式向后滑动位数的计算仅与模式本身的结构有关，与主串无关。  

### 字符串的前缀、后缀和部分匹配值  
前缀：除最后一个字符外，字符串的所有**头部子串**。  
后缀：除第一个字符外，字符串的所有**尾部子串**。  
部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。  
以'ababa'为例：  
+ 'a'的前缀和后缀都为∅，则最长相等前后缀长度=0  
+ ’ab'的前缀为{a}，后缀为{b}，{a}∩{b}=∅，最长相等前后缀长度=0  
+ 'aba'的前缀为{a, ab}，后缀为{a, ba}，{a, ab}∩{a, ba} = {a}，最长相等前后缀长度=1  
+ 'abab'的前缀为{a, ab, aba}，后缀为{b, ba, bab}，{a, ab, aba}∩{b, ab, bab} = {ab}，最长相等前后缀长度=2  
+ 'ababa'的前缀为{a, ab, aba, abab}，后缀为{a, ba, aba, baba}，{a, ab, aba, abab}∩{a, ba, aba, baba} = {a， aba}，最长相等前后缀长度=3。  

故字符串'ababa'的部分匹配值为00123。  
某趟发生失配时，如果对应的部分匹配值为0,即已匹配相等序列中没有相等的前后缀，此时移动的位数最大，直接将子串首字符右移到主串i位置进行下一趟比较；如果已匹配相等序列中存在最大相等前后缀，那么将子串向右滑动到和该相等前后缀对齐，然后再从主串i的位置进行下一趟比较。  

### KMP算法的原理是什么？  
已知：移动位数 = 已匹配的字符数 - 对应的部分匹配值  
写成：`Move = (j - 1) - PM(j - 1)`  
使用部分匹配值时，每当匹配失败，就去找它的前一个元素j-1的部分匹配值，这样使用起来有些不方便，所以将PM表右移一位，这样哪个元素匹配失败，直接看它自己的部分匹配值即可。  
PM表右移一位，就得到了next数组。  
我们注意到：  
+ 第一个元素右移以后空缺的用-1来填充，因为若是第一个元素匹配失败，则需要将子串向右移动一位，而不需要计算子串移动的位数。  
+ 最后一个元素在右移的过程中溢出，因为原来的子串中，最后一个元素的部分匹配值是下一个元素使用的，但显然已没有下一个元素，故可以舍去。  

这样，上式就改写为  
`Move = (j - 1) - next[j]`  
相当于将子串的比较指针回退到  
**j = j - Move = j - ((j - 1) - next[j]) = next[j] + 1**  
有时为了使公式更加简洁、计算简单，将**next数组整体+1**  
最终得到子串指针变换公式  
**j = next[j]**  
在实际的匹配中，子串在内存里是不会移动的，而是指针在变化。next[j]的含义是：**在子串的第j个字符与主串发生失配时，则跳到子串的next[j]位置重新与主串当前位置进行比较。  
求next值的程序如下：  
```C
void get_next(String T, int next[])
{
    int i = 1, j = 0;
    next[1] = 0;
    while(i < T.length)
    {
        if(j==0 || T.ch[i]==T.ch[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else
        {
            j = next[j];
        }
    }
}
```
KMP匹配算法：  
```C
int Index_KMP(String S, String T, int next[])
{
    int i = 1, j = 1;
    while((i <= S.length)&&(j < T.length))
    {
        if(j==0 || S.ch[i] == S.ch[j])
        {
            // 继续比较后继字符
            ++i;
            ++j;
        }
        else
        {
            j = next[j];// 模式串向右移动
        }
    }
    if(j > T.length)
    {
        return i - T.length;// 匹配成功
    }
    else
    {
        return 0;
    }
}
```  
尽管普通模式匹配的时间复杂度为O(mn)，KMP算法的时间复杂度是O(m+n)，但在一般情况下，普通匹配模式的实际执行近似为O(m+n)，因此至今仍被采用。KMP算法仅在主串和子串有很多“模式匹配”时才显得比普通算法快得多，其主要优点是主串不回溯。  

---  
## KMP算法的进一步优化  
修正后的next数组命名为nextval。计算next数组修正值的算法如下，此时匹配算法不变。  
```C
void get_nextval(String T, int nextval[])
{
    int i = 1, j = 0;
    nextval[1] = 0;
    while(i < T.length)
    {
        if(j == 0 || T.ch[i] == T.ch[j])
        {
            ++i;
            ++j;
            if(T.ch[i] != T.ch[j])
            {
                nextval[i] = j;
            } else {
                nextval[i] = nextval[j];
            }
        } else {
            j = nextval[j];
        }
    }
}
```