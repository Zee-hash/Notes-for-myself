# 进程管理
---
## 进程与线程
### 进程的概念  
在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。  
为了使参与并发执行的程序（含数据）能独立地运行，必须配置一个专门的数据结构，称之为进程控制块Process Control Block。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像(进程实体)。所谓创建进程，实质上是创建进程映像中的PCB。  
**进程是进程实体的运行过程，是系统进行资源分配和调度的一个基本单位**  
进程的其它定义：  
+ 进程是程序的一次执行过程
+ 进程是一个程序及其数据在处理机上顺序执行所发生的活动
+ 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位  
### 进程的特征  
+ 动态性。进程是程序的一次执行，它有着创建、阻塞、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。**动态性是进程最基本的特征**  
+ 并发性。之多个进程同时存在与内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用效率。  
+ 独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡是未建立PCB的程序，都不能作为一个独立的单位参与运行。  
+ 异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。  
+ 结构性。每个进程配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。  
### 进程的状态与转换  
进程在其生命周期内，由于系统中个进程之间的相互制约关系及系统运行环境的变化，使得进程的状态也在不断地发生改变。进程的状态通常有以下五种，其中前三种是进程的基本状态。  
+ 运行态。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。  
+ 就绪态。进程已处于准备运行的状态，即进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行。  
+ 阻塞态。进程正在风带某一事件而暂停运行，如等待某资源为可用(除处理机之后的其他资源)或等待输入/输出完成。进程处于阻塞态时，及时得到处理机，也不能运行。  
+ 创建态。进程正在被创建，尚未转到就绪态。创建进程通常包含多个步骤：  
  - 申请空白的PCB
  - 向PCB中写入控制和管理进程的信息
  - 系统为进程分配运行所需的资源
  - 分配成功进程即可转入就绪态  
+ 结束态。进程正在从系统中消失，可能是进程正常结束或其他原因中断运行。进程需要结束运行时，系统首先需要置该进程为结束态，然后进一步处理释放资源和回收等工作。  
#### 转化条件：  
+ 就绪态->运行态：处于就绪态的进程被调度后，得到处理机资源。  
+ 进行态->就绪态：处于运行态的进程在分配给它的时间片用完之后，让出处理剂。在可剥夺的操作系统中，如果有更高优先级的进程处于就绪态时，则会转去执行更高优先级的进程，当前进程则转入就绪态。  
+ 运行态->阻塞态：进程请求某一资源的使用和分配或等待某一事件发生时。进程通过系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核的形式。  
+ 阻塞态->就绪态：进程等待的事件到来时，**中断处理程序**就把相应进程的状态由阻塞态转换为就绪态。  
### 进程控制
进程控制的主要功能是对系统中所有的进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
1. 进程的创建  
允许一个进程创建另一个进程。创建进程的称为父进程，被创建的进程称为子进程。**子进程可以继承父进程所拥有的资源**。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。父进程一旦被撤销，其子进程也必须同时被撤销。  
在操作系统中，**终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等**都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语）：  
+ 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB。若PCB申请失败，则创建失败。  
+ 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（相关信息将存储在PCB中）。若资源不足，进程则处于阻塞态。  
+ 初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。  
+ 若进程就须队列能够接纳新进程，则将新进程插入就绪队列，等待被调度。  
2. 进程的终止  
引起进程终止的事件主要有：  
+ 正常结束，表示进程的任务已经完成并准备退出运行。  
+ 异常结束，标识进程在运行时，发生了某种异常事件，是程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。  
+ 外界干预，进程应外界的请求而终止运行。  
操作系统终止进程的过程如下（撤销原语）：  
+ 根据被终止进程的标识符，检索PCB，从中读出进程的状态。  
+ 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。  
+ 若该进程还有子进程，则应把其所有子进程终止。  
+ 将该进程所拥有的全部资源归还给其父进程，或归还给操作系统。  
+ 将该PCB从所在队列（链表）删除。  
3. 进程的阻塞和唤醒  
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做等，有系统自动执行阻塞原语(Block)，使自己由运行态变成阻塞态。**可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程，才有可能将其转为阻塞态。阻塞原语的执行过程如下：  
+ 找到将要被阻塞进程的标识号对应的PCB。  
+ 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。  
+ 把该PCB插入相应事件的等待队列。  
当被阻塞进程所期待的事件发生时，由有关进程（如提供数据的进程）调用唤醒原语(Wakeup)，将等待该时间的进程唤醒。唤醒原语的执行过程如下：  
+ 在该事件的等待队列找到相应进程的PCB。  
+ 将其从等待队列移除，并置其状态为就绪态。  
+ 把该PCB插入就绪队列，等待调度程序调度。  
**Block原语是由被阻塞进程自我调用实现的，Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的**  
4. 进程切换  
进程切换是指处理机从一个进程的运行切换到另一个进程上运行，在这个过程中，进程的运行环境发生了实质性的变化。进程切换的过程如下：  
+ 保存处理机上下文，包括程序计数器和其他寄存器。  
+ 更新PCB信息。  
+ 把进程的PCB移入相应的队列，如就绪、某事件的阻塞队列。  
+ 选择另一个进程执行，并更新其PCB。   
+ 更新内存管理的数据结构。  
+ 恢复处理机上下文。  
### 进程的组织  
进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它一般由以下三部分组成：  
1. 进程控制块  
进程创建时，操作系统新建一个PCB结构，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。**PCB是进程实体的一部分，是进程存在的唯一标志**。  
创建一个进程时，系统为该进程建立一个PCB；进程执行时，系统通过PCB了解现行状态信息，以便对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程。  
PCB通常包含的内容：  
+ 进程描述信息。  
  - 进程标识符PID
  - 用户标识符UID  
+ 进程控制和管理信息  
  - 代码当前状态
  - 进程优先级
  - 代码运行入口地址
  - 程序的外存地址
  - 进入内存时间
  - 处理机占用时间
  - 信号量使用  
+ 资源分配清单  
  - 代码段指针
  - 数据段指针
  - 堆栈段指针
  - 文件描述符
  - 键盘
  - 鼠标  
+ 处理机相关信息  
  - 通用寄存器值
  - 地址寄存器值
  - 控制寄存器值
  - 标志寄存器值
  - 状态字  
为了方便进程的管理和调度，需要将各进程的PCB用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。  
+ 链接方式：将同一状态的PCB链接成一个队列，不同的状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。  
+ 索引方式：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同众状态对应不同的索引表，如就绪索引表和阻塞索引表。  
2. 程序段  
程序段就是能够被进程调度程序调度到CPU执行的程序代码段。**程序可被多个进程共享，即多个进程可以运行同一个程序**。  
3. 数据段  
一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是进程执行产生的中间或最终结果。
### 进程的通信  
进程通信指的是进程之间的信息交换。PV操作是低级通信方式，高级通信方式时指出以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。  
1. 共享存储  
在通信的进程之间存在一块可被直接访问的存储空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时，需要使用同步互斥工具，对共享空间的读/写进行控制。共享存储又分为两种：  
+ 基于数据结构的共享  
+ 基于存储区的共享  
操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则需要由用户自己安排读/写指令完成。  
**用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，要想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。**  
2. 消息传递  
在消息传递系统中，进程间的数据交换是以格式化的消息为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法来实现进程的通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。  
+ 直接通信方式。发送进程直接把消息发送给接收进程，并把它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。  
+ 间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。计算机网络中的一种应用为电子邮件系统。  
3. 管道通信  
管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。  
在Linux中，管道是一种使用非常频繁的通信机制。从本质上来说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下：  
+ 限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux系统中，该缓冲区的大小为4KB，这使得它的大小不像一般文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用。  
+ 读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。  
在管道通信中，存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中还有数据，进程就能够从缓冲区中读出，而不必担心会因为其它进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。这决定了管道通信是半双工的。  
### 线程概念和多线程模型  
1. 线程的基本概念  
引入线程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量，增加并发程度；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。  
线程最直接的理解就是“轻量级进程”。它是一个基本的CPU执行单位，也是程序执行流的最小单位，由**线程ID、程序计数器、寄存器集合和堆栈**组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。  
引入线程后，进程的内涵发生了改变，**进程只作为除CPU外的系统资源的分配单元，线程则作为处理机的分配单元**。由于一个进程内部有多个线程，若线程的切换发生在同一进程内部，则只需要很少的时空开销。  
2. 进程与线程的比较  
+ 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中进行线程切换，会引起进程切换。  
+ 拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位。而线程不拥有系统资源（仅拥有必不可少的资源），但线程可以访问其所属进程的系统资源。  
+ 并发性。在引入线程的操作系统中，不见线程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。  
+ 系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换时，涉及当前进程的CPU环境的保存以及新调度到进程CPU环境的设置，而线程切换时仅需保存和设置少量寄存器的内容，开销很小。此外，由于同一个进程内的多个线程共享进程的地址空间，因此这些线程之间的同步和通信非常容易实现，甚至无需操作系统的干预。  
+ 地址空间和其他资源。进程的地址空间之间相互独立，同一进程的各线程共享进程的资源，某进程内的线程对于其他进程不可见。  
+ 通信方面。进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的统一性，而线程间可以直接读/写进程数据段来进行通信。  
3. 线程的属性  
线程的主要属性如下：  
+ 线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的状态标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。  
+ 不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。  
+ 同一个进程中的各个线程共享该进程所拥有的资源。  
+ 线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。  
+ 一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。  
4. 线程的实现方式  
线程的实现可以分为两类：用户级线程User-Level Thread和内核级Kernel-Level Thread。内核级线程又称内核支持的线程。  
在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行期间，可以通过调用线程库中的派生例程创建一个在相同进程运行的新线程。  
在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。  
有些系统使用组合方式的多线程实现。线程创建完全在用户空间内完成。线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射一些到内核级线程上。  
5. 多线程模型  
有些系统同时支持用户级线程和内核级线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。  
+ 多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户线程对操作系统不可见。  
优点：线程管理是在用户空间完成的，因而效率较高。  
缺点：一个线程在使用内核服务时被阻塞，整个进程都会被阻塞；多个线程不能并行地运行在多处理上。  
+ 一对一模型。将每个用户级线程映射到一个内核级线程。  
优点：当一个线程被阻塞后，运行另一个线程继续执行，因此并发能力较强。  
缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。  
+ 多对多模型。将n个用户级线程映射到m个内核级线程上，要求m<=n。  
特点：这种方式既克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程而开销太大的缺点。此外，还拥有上述两种模型的优点。

---
## 处理机调度
### 调度的概念  
1. 调度的基本概念  
在多道程序系统中，进程的数量往往多于处理机的数量，因此进程争用处理机的情况在所难免。处理机调度是对**处理机**进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程的并发地执行。  
处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。  
2. 调度的层次  
一个作业从提交到完成，往往要经历以下三级调度。  
+ 作业调度（高级调度）。其主要任务是按照一定的原则从**外存**上处于后备队列的作业中挑选一个或多个作业，为它们分配内存、输入输出设备等必要的资源，并建立相应的进程，使得它们获得竞争处理机的权利。**作业调度是内存和辅存之间的调度，每个作业只能调入一次、调出一次。**  
+ 中级调度（内存调度）。其作用是提高内存利用率和系统吞吐量。为此，应将那些暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起态。当它们已具备条件且内存又稍有空闲时，由中级调度来决定把外存上那些已具备运行条件的挂起态进程，再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。  
+ 进程调度（低级调度）。其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率一般很高。  
3. 三级调度的联系  
**作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入到就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间教宽松时，通过中级调度选择具有运行条件的进程，将其唤醒。**  
+ 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。  
+ 作业调度次数少，中级调度次数略多，进程调度频率最高。  
+ 进程调度是最基本的，不可或缺。  
### 调度的时机、切换与过程  
进程调度和切换程序是操作系统内核程序。请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪程序之后，才会进行进程间的切换。  
现代操作系统中，不能进行进程的调度和切换的情况有以下几种：  
+ 在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。  
+ 进程在操作系统内核程序临界区中。进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其它并行程序进入，在解锁前不应切换到其他进程运行，以加快共享数据的释放。  
+ 其他需要完全屏蔽中断的原子操作的过程中。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，中断也会被屏蔽。  
若上述过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。  
应该进行进程调度与切换的情况如下：  
+ 发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是非剥夺调度。  
+ 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了剥夺方式的调度。  
**进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的线程信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。  
### 进程调度方式  
+ 非剥夺调度方式。又称非抢占方式，非剥夺调度方式是指当一个进程正在处理机上执行时，即使有更为重要或迫切的进程进入就绪队列，仍然让正在执行的进程继续执行，知道该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或迫切的进程。  
在这种方式下，一旦把CPU分配给一个进程，该进程就会保持CPU直到终止或转换到等待态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统或大多数的实时系统。  
+ 剥夺调度方式。又称抢占方式，剥夺调度方式是指当一个进程正在处理上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立刻暂停正在执行的进程，将处理机分配给这个更为重要或迫切的进程。  
采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一个任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。  
### 调度的基本准则  
准则主要用来评价处理机调度算法。  
+ CPU利用率，应尽可能地使得CPU保持忙的状态，使其资源利用率最高。  
+ 系统吞吐量，**表示单位时间内CPU完成作业的数量**。长作业需要消耗较长的处理机时间，因此会降低系统吞吐量。而对于短作业，它们所需要消耗的处理机时间比较短，因此能提高系统吞吐量。  
+ 周转时间，**从作业提交到作业完成所经历的时间**,是作业等待、在就绪队列中排队、在处理机上运行及进行输入输出操作所花费时间的总和。  
**周转时间=作业完成时间-作业提交时间**  
**平均周转时间=作业周转时间之和/作业个数**  
**带权周转时间=作业周转时间/作业实际运行时间**  
**平均带权周转时间=作业带权周转周期之和/作业个数**  
+ 等待时间，**等待时间是指进程处于等处理机状态的时间之和**，等待时间越长，用户满意度越低。处理机调度算法实际并不影响作业执行或输入输出操作的时间，只影响作业在就绪队列中等待所花的时间。  
+ 响应时间，响应时间是指**从用户提交请求到系统首次产生响应所用的时间**。在交互式系统中，这项指标是衡量调度算法的重要指标之一。  
设计调度程序，一方面要满足特定用户的要求（如某些实时和交互进程的快速相应要求），另一方面要考虑系统整体效率（如减少整个系统的进程平均周转时间），同时还要考虑调度算法的开销。  
### 典型的调度算法  
+ 先来先服务调度算法FCFS  
可用于作业调度和进程调度。在作业调度中，算法每次从后备队列中选择最先进入该队列的一个或几个作业，把它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。  
FCFS调度算法属于不可剥夺算法。**若一个长作业先到达系统，就会使得后续的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。**  
FCFS调度算法的特点是算法简单，但效率低；对长作业有利，但对短作业不利；有利于CPU繁忙型作业，但不利于I/O繁忙型作业。  
+ 短作业优先调度算法SJF  
可用于作业调度和进程调度。在作业调度中，调度算法从后备队列中选择一个或若干个**估计**运行时间最短的作业，将它们调入内存运行。在进程调度中，调度算法从就绪队列中选择一个**估计**运行时间最短的进程，将处理机分配给它，使之立即执行，知道完成或发生某事件而阻塞时，才释放处理机。  
**若有一长作业进入系统的后备队列，由于调度算法总是优先调度那些短作业，将导致长作业长时间不被调度(饥饿现象)**。算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。由于作业的长短只是根据用户所提供的估计运行时间而定的，而用户提供的时间不一定准备，致使该算法不一定能做到真正的短作业优先调度。  
**SJF调度算法的平均等待时间、平均周转时间最少**  
+ 优先级调度算法  
优先级调度算法又称优先权调度算法，算法中的优先级用于描述作业运行时的紧迫程度。可用于作业调度和进程调度。在作业调度中，优先级调度算法每次从后备队列中选择一个优先级最高的一个或几个作业，把它们调入内存，分配必要的资源，创建进程并放入就绪队列中。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，把处理机分配给它，使之投入运行。  
根据新的更高优先级的进程能否抢占正在执行的进程，可将调度算法分为以下两种：  
  - 非剥夺式优先级调度算法
  - 剥夺式优先级调度算法  

  根据进程创建后优先级是否可以改变，可以将进程分为以下两种：  
  - 静态优先级。优先级在进程创建时就已经确定，而在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。  
  - 动态优先级。在进程运行的过程中，根据进程情况的变化动态调整优先级。调整的主要依据有占用CPU时间的长短、就绪进程等待CPU时间的长短。  

  一般来说，进程优先级的设置可以参考以下原则：  
  - 系统进程>用户进程
  - 交互式进程>非交互式进程(前台进程>后台进程)
  - I/O型进程>计算型进程  
+ 高响应比优先调度算法  
高响应比优先算法主要用于作业调度，是对FCFS和SJF调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备队列中每个作业的响应比，从中选出响应比最高的作业投入运行。  
**响应比 = (等待时间+要求服务时间) / 要求服务服务时间**  
  - 作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业。SJF  
  - 要求服务时间要求时，等待时间越长，响应比越高。FCFS  
  - 对于长作业，作业的相应比也会随着等待时间的增加而变高，克服了饥饿状态，兼顾了长作业。  
+ 时间片轮转调度算法  
时间片轮转调度算法主要用于分时系统。在这种算法中，系统将所有的就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列的第一个进程执行，即先来先服务的原则，但仅能运行一个时间片。在使用完一个时间片后，即使进程并未完成运行，也必须让出处理机给下一个就绪的进程，而被剥夺处理机的进程返回到就绪队列的末尾重新排队，等候再次运行。  
在时间片轮转算法中，时间片的选择对系统性能影响很大。若时间片足够大，以至于所有的进程都能在一个时间片内执行完毕，则此时相当于FCFS。若时间片很小，则处理机在频繁地切换进程，使处理机的开销增大，而真正用于运行用户进程的时间将减少。  
时间片的长短通常由以下因素确定：系统的响应时间、就绪队列的进程数目和系统的处理能力。  
+ 多级反馈队列调度算法  
多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。  
多级反馈队列调度算法的实现思想如下：
  - 设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。  
  - 赋予各个队列中进程执行的时间片大小各不相同。在优先级越高的队列中，每个进程的运行时间片越小。  
  - 一个新进程进入内存后，首先把它放在第1级队列的末尾，按照FCFS排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；若在一个时间片内未完成，调度程序便将该进程转入第2级队列的末尾，在同样按照FCFS原则等待调度执行......如此下去，当一个长进程从第1级队列依次到第n级队列后，在第n级队列中便采用时间片轮转的方式运行。  
  - 仅当第1级队列为空时，调度程序在调度第2级队列中的进程运行，仅当第1～(i-1)级队列均为空时，才会调度第i级队列中的进程运行。若处理机正在执行第i级队列中的某进程，这时又有新进程进入优先级就较高的队列，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回第i级队列的末尾，把处理机分配给新到的优先级更高的进程。  
---
## 进程同步
### 进程同步的基本概念  
在多道程序环境下，进程是并发执行的，不同的进程之间存在不同的制约关系。为了协调进程之间的相互制约的关系，引入了进程同步的概念。  
1. 临界资源  
虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所用，将这种一次仅允许一个进程使用的资源称为临界资源。许多物理设备属于临界资源，如打印机等，此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。  
**对临界资源的访问，必须互斥地进行，在每个进程中，`访问临界资源的那段代码`称为临界区。为了保证临界资源的正确使用，可把临界资源的访问分为4个部分：  
+ 进入区。为了进入临界区使用临界资源，在进入去要检查可否进入临界区，若能够进入临界区，则应设置正在访问临界区的标志，以组阻止其他进程同时进入临界区。  
+ 临界区。进程中访问临界资源的那段代码。  
+ 退出区。将正在访问临界区的标志清除。  
+ 剩余区。代码的剩余部分。  
```伪C
do {
  entry section;
  critical section;
  exit section;
  remainder section;
} while(true)
```
2. 同步  
同步也称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的制约关系源自于它们之间的相互合作。  
3. 互斥  
互斥也称间接制约关系，当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问次临界资源。  
为了禁止两个进程同时进入临界区，同步机制应遵循以下准则：  
+ **空闲让进**：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。  
+ **忙则等待**：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。  
+ **有限等待**：对请求访问的进程，应保证能在有限时间内进入临界区。  
+ **让权等待**：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。  
### 实现临界区互斥的基本方法  
1. 软件实现方法  
在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区则在退出区修改标志。  
+ 单标志法  
该算法设置一个公用整型变量`turn`，用于指示被允许进入临界区的进程编号，即若`turn=0`，则允许P0进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，若某个进程不在进入临界区，则另一个进程也将无法进入临界区（**违背空闲让进**）。  
```伪C
P0
while(turn != 0);
critical section;
turn = 1;  // 若结束后P1一直为执行，这P0即使临界区空闲也无法进入
remainder section;
P1
while(turn != 1);
critical section;
turn = 0;
remainder section;
```  
+ 双标志法先检查  
在每个进程访问临界区资源之前，先检查临界区是否正在被访问，若正在被访问，在进程需要等待；否则，进程才进入自己的临界区。为此，设置一个数据`flag[i]`，如第i个元素值为FALSE，表示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区。  
缺点：Pi和Pj可能同时进入临界区。按①②③④执行时，会同时进入临界区（违背忙则等待）。
```伪C
Pi进程
while(flag[j]);①
flag[i] = TRUE;③
critical section;
flag[i] = FALSE;
remainder section;
Pj进程
while(flag[i]);②
flag[j] = TRUE;④
critical section;
flag[j] = FALSE;
remainder section;
```  
+ 双标志后检查  
先把自己的标志设置为TRUE，再检测对方的状态标志，若对方标志为TRUE，则进程等待；否则进入临界区。  
缺点：当两个进程都想使用临界区的时候，即`(flag[i]==TRUE)&&(flag[j]==TRUE)`的时候，则会由于等待对方完成，结果谁也无法进入临界区，从而导致“饥饿”现象。
```伪C
Pi进程
flag[i] = TRUE;
while(flag[j]);
critical section;
flag[i] = FALSE;
remainder section;
Pj进程
flag[j] = TRUE;
while(flag[i]);
critical section;
flag[j] = FALSE;
remainder section;
```  
+ Peterson's Algorithm。为了防止两个进程为进入临界区而无限期等待，又设置了一个变量 `turn`，每个进程在设置自己的标志后再设置`turn`标志。这时，再同时检测另一个进程状态标志和不允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。  
```伪C
Pi进程
flag[i] = TRUE;turn = j;
while(flag[j]&&turn==j);
critical section;
flag[i] = FALSE;
remainder section;
Pj进程
flag[j] = TRUE;turn = i;
while(flag[j]&&turn==i);
critical section;
flag[j] = FALSE;
remainder section;
```  
2. 硬件实现方法  
计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持临界区问题的方法称为低级方法，或称元方法。  
+ 中断屏蔽方法  
当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入临界区访问的最简方法是，禁止一切中断发生，或称之为屏蔽中断、关中断。**因为CPU只在发生中断时引起进程切换，因此屏幕中断能够保证当前运行的进程让临界区代码顺利地执行完**，进而保证互斥的正确实现，然后执行开中断。  
这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的，但将关中断的权利交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。  
+ 硬件指令方法  
TestAndSet指令，这是一条原子指令，即执行该代码时不允许被中断。其功能是读出指定的标志后将该标志设置为真。  
```
boolean TestAndSet(boolean *lock)
{
  boolean old;
  old = *lock;
  *lock = true;
  return old;
}
```  
实际使用时可为每个临界资源设置一个共享型的boolean变量`lock`，表示资源的两种状态；true表示正在被占用，初值为false。在进程访问临界资源前，利用TestAndSet检查和修改标志`lock`，若有进程在临界区，则重复检查，直到进程退出。  
```
while TestAndSet(&lock);
critical section;
lock = false;
remainder section;
```  
Sway指令，功能是交换两个字节的内容。  
```
Swap(boolean *a, boolean *b)
{
  boolean temp;
  temp = *a;
  *a = *b;
  *b = temp;
}
```  

实际使用时为每个临界资源设置一个共享booleam变量`lock`，初值为false，在每个进程中再设置一个局部boolean变量`key`，用于与`lock`交换信息。在进入临界区前，先利用Swap指令交换`lock`与`key`的内容，然后再检查`key`的状态。有进程在临界区时，重复交换和检查过程，直到进程退出。  
```
key = true;
while(key != false)
  Swap(&lock, &key);
critical section;
lock = false;
remainder section;
```  
硬件方法的优点
+ 适用于任意数目的进程
+ 不管是单处理机还是多处理机，简单，容易验证其正确性
+ 可以支持进程有多个临界区，只需为每个临界区设立一个布尔变量  

硬件方法的缺点：进程等待进入临界区可能要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致饥饿现象。

### 信号量  
信号量机制是一种功能较强的机制，可以用来解决互斥与同步问题，它只能被两个标准的原语`wait(S)`和`signal(S)`访问，也可记为P操作和V操作。  
原语是完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来完成。原语功能的不被中断执行特效了在单处理机上可由软件通过屏蔽中断方法实现。  
原语之所以不能被中断执行，是因为原语对变量的操作若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。若能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。  
+ 整型信号量  
wait操作中，只要信号量S<=0，就会不断地测试。因此，该机制并为遵循让权等待原则，而是一直让进程处于忙等的状态。
  ```
  wait(S)
  {
    while(S <= 0);
    S = S - 1;
  }
  signal(S)
  {
    S = S + 1;
  }  
+ 记录型信号量  
除需要一个用于代表资源数目的整型变量value以外，再增加一个进程链表L，用于链接所有等待该资源的进程。  
  ```
  typedef struct
  {
    int value;
    struct process *L;
  } semaphore;

  void wait(semaphore S)
  {
    S.value--;
    if(S.value < 0)
    {
      add this process to S.L;
      block(S.L);
    }
  }

  void signal(semaphore S)
  {
    S.value++;
    if(S.value <= 0)
    {
      remove a process P from S.L;
      wakeup(P);
    }
  }
  ```  
+ 利用信号量实现同步  
信号量机制能解决进程间的各种同步问题。设S为实现进程P1、P2同步的公共信号量，**初值为0**。进程P2需要使用进程P1中的结果，所以一前一后。  
**由P1进程在产生结果后执行V(S)，P2进程需要使用P1结果之前执行P(S)，就可以实现具有一前一后关系的进程同步问题。**  
+ 利用信号量实现进程互斥  
信号量机制也能用于解决进程间的互斥问题。设S为实现进程P1、P2互斥的信号量，由于每次只允许一个进程进入临界区，**S的初值为1**（即可用资源数为1）。  
**只需把访问临界资源的代码（临界区）放到两个进程的P(S)和V(S)之间，即可实现进程的互斥访问。**  
+ 利用信号量实现前驱关系  
信号量机制也可以用来解决程序之间或语句之间的前驱关系。为了使程序能够按照一定的顺序运行，应设置若干**初始值为0**的信号量。  
**前驱节点V(S)，后继节点P(S)**  
### 管程  
+ 定义  
系统中的各种硬件和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们内部结构和实现细节。**管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。**  
+ 管程的组成  
  - 局部于管程的共享结构数据说明
  - 对该数据结构进行操作的一组过程
  - 对局部于管程的共享数据设置初始值的语句。 
+ 管程的基本特性  
  - 局部于管程的数据只能被局部于管程内的过程所访问
  - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据  
  - 每次仅允许一个进程在管程内执行某个内部过程。

---
## 死锁  
### 死锁的概念  
1. 死锁的定义  
在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统处理能力，然而，多个进程的并发执行也带来了新的问题——死锁。所谓死锁，是指多个进程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。  
2. 死锁产生的原因  
+ 系统资源的竞争  
通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行的过程中，会因争夺资源而陷入僵局。只有对不可剥夺的资源竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。  
+ 进程推进顺序非法  
进程在运行的过程中，请求和释放资源的顺序不当，也同样会导致死锁，如著名的哲学家进餐问题。  
信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。  
+ **死锁产生的必要条件**  
  - 互斥条件  
  进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅能为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。  
  - 不剥夺条件  
  进程所获得资源在未使用完之前，不能被其他进程强行夺走，及只能由获得该资源的进程自己来释放。  
  - 请求并保持  
  进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占用，此时请求进程被阻塞，但对自己已保持的资源保持不放。  
  - 循环等待条件  
  存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待态的进程集合{P1,P2,...,Pn}，其中Pi等待的资源被Pj(j=i+1)占有，Pn等待的资源被P0所占有。  

### 死锁的处理策略
为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当发生死锁时能检测出死锁，并有能力恢复。  
1. 死锁预防  
设置某些限制条件，破坏产生死锁的4个必要条件之一或几个，以防止发生死锁。  
2. 避免死锁  
在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。  
3. 死锁的检测及解除  
无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。  
### 死锁预防  
+ 破坏互斥条件  
若允许系统资源都能共享，则系统不会进入死锁状态。但实际有些资源根本不能同时访问，所以，破坏互斥条件而预防死锁的方法不太可行，而且在有些场合应该保护这种互斥性。  
+ 破坏不剥夺条件  
当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足的时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占用的资源会被暂时释放，或者说是被剥夺，或从而破坏了不剥夺条件。  
该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复的申请和释放资源会增大系统的开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。  
+ 破坏请求并保持条件  
采用预先静态分配方法，即进程在运行前一次申请它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行，这些资源就一直归它所有，不再提出其他资源请求，这样就可以保证系统不会发生死锁。  
这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致饥饿现象，由于个别资源长期被其他进程占用，将致使等待该资源的进程迟迟不能开始运行。  
+ 破坏循环等待条件  
为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中就只能申请编号大于Ri的资源。  
这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定的顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。  
### 死锁避免  
避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件比较弱，可以获得较好的系统性能。  
1. 系统安全状态  
避免死锁的方法中，允许进程动态地申请资源，但在系统进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则让进程等待。  
所谓安全状态，是指系统能够按照某种进程推进顺序(P1, P2,...， Pn)为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1, P2, ..., Pn为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。  
**并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。**  
2. 银行家算法  
银行家算法的思想是：把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程要操作系统请求分配资源相当于用于向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，若系统现存的资源可以满足它的最大需求量，则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，应先测试该进程已占用的资源数与本次的申请资源数之和是否超过该进程对资源的最大需求量。若超过则拒绝分配资源，若未超过则在测试系统现存的资源能否满足进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。  
### 死锁检测与解除  
若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。  
1. 资源分配图  
系统死锁可利用资源分配图来描述。用圆圈代表一个进程，用框代表一类资源。由于一类资源可能有多个，因此用框中的一个圆代表一类资源中的一个资源。  
从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源。  
从资源到进程的边称为分配边，表示该类资源已有一个资源分配给该进程。  
2. 死锁定理  
简化资源分配图可检测系统S是否为死锁状态，简化方法如下：  
+ 在资源分配图中，找出既不阻塞又不孤点的进程Pi(即该进程申请资源的数量小于等于系统中已有的空闲资源数量)。消去它所有的请求边和分配边。使之称为孤立的结点。  
+ 进程Pi释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变成非阻塞进程，继续消边，若能消去所有的边，则该图是可完全简化的。  
**S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的，该条件为死锁定理。**  
3. 死锁解除  
一旦出现死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有：  
+ 资源剥夺法  
挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。  
+ 进程撤销法  
强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。  
+ 进程回退法  
让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非剥夺。要求系统保持进程的历史信息，设置还原点。
