# 排序  
---  
## 排序的基本概念  
### 排序的定义  
排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下：  
输入：n个记录R<sub>1</sub>，R<sub>2</sub>，···，R<sub>n</sub>，对应的关键字为k<sub>1</sub>，k<sub>2</sub>，···，k<sub>n</sub>。  
输出：输入序列的一个重排R<sub>1</sub>՛，R<sub>2</sub>՛，···，R<sub>n</sub>՛，使得k<sub>1</sub>՛≤k<sub>2</sub>՛≤···≤k<sub>n</sub>՛(或满足其它关系)。  
算法的稳定性：若待排序表中有两个元素R<sub>i</sub>，R<sub>j</sub>，其对应的关键字相同即key<sub>i</sub> = key<sub>j</sub>，且在排序前R<sub>i</sub>在R<sub>j</sub>的前面，若使用某一排序算法排序后，R<sub>i</sub>仍然在R<sub>j</sub>的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。  
在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：  
+ 内部排序，是指在排序期间元素全部存放在内存中的排序  
+ 外部排序，是指在排序期间元素无法同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序  

一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。并非所有的内部排序算法都要基于比较，事实上，基数排序就不基于比较。  
每种排序算法都有各自的优缺点，适合在不同的环境中使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。  

---  
## 插入排序  
> 每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。  

由插入排序的思想可以引申出三种排序算法：直接插入排序
折半插入排序和希尔排序。  
### 直接插入排序  
假设在排序过程中，待排序表L[1···n]在某次排序过程中的某一时刻状态如下：  

|有序序列L[1···i-1]|L(i)|无序序列L[i+1···n]|  
|---|---|---|  

要将元素L(i)插入到已有序的子序列中L[1···i-1]中，需要执行以下操作，其中L[]表示表，L()表示元素：  
+ 查找出L(i)在L[1···i-1]中的插入位置k  
+ 将L[k···i-1]中的所有元素依次后移一个位置  
+ 将L(i)复制到L(k)  

为了实现对L[1···n]的排序，可以将L(2)~L(n)依次插入到前面已排好序的子序列中，初始L[1]可视为是一个已排好序的子序列。上述操作执行n-1次就能得到一个有序的表。插入排序在实现上通常采用就地排序（空间复杂度为O(1）），因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。  
直接插入排序代码如下：  
```C
void InsertSort(ElemType A[], int n)
{
    int i, j;
    for(i = 2; i <= n; i++)
    {
        if(A[i] < A[i-1])// 小于其前驱时，才表示需要插入到有序子序列中，否则直接插入到最后
        {
            A[0] = A[i];// 复制为哨兵，A[0]不存放元素
            for(j = i-1; A[0] < A[j]; --j)
            {
                A[j+1] = A[j];// 大于哨兵的元素后移
            }
            A[j+1] = A[0];// 复制到插入位置
        }
    }
}
```  
直接插入排序算法的性能分析如下：  
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。  
时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。  
在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)。  
在最坏情况下，表中元素顺序刚好与排序结构中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大。  
平均情况下，考虑待排序表中元素是随机的，此时可取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n<sup>2</sup>/4。  
因此，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)。  
稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。  
适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。  

### 折半插入排序  
从直接插入排序算法中，每趟插入的过程中都进行了两项工作：  
+ 从前面的有序子序列中查找出待插入元素应该被插入的位置  
+ 给插入位置腾出空间，将待插入元素复制到表中的插入位置  

在该算法中，总是边比较边移动元素。  
下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法左如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下：  
```C
void InsertSort(ElemType a[], int n)
{
    int i, j, low, high, mid;
    for(i = 2; j <= n; i++)
    {
        A[0] = A[i];
        low = 1, high = i-1;// 折半查找的范围
        while(low <= high)
        {
            mid = (low + high) / 2;
            if(A[mid] > A[0])
            {
                high = mid - 1;// 查找左半子表
            }
            else
            {
                low = mid + 1;// 查找右半子表
            }
        }
        for(j = i-1; j >= high+1; --j)
        {
            A[j+1] = A[j];// 统一后移元素，空出插入位置
        }
        A[high+1] = A[0];// 插入操作
    }
}
```  
性能分析：  
折半插入排序仅减少了比较元素的次数，约为O(nlog<sub>2</sub>n)，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O(n<sup>2</sup>)，但对于数据量不大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。  

### 希尔排序  
从前面的分析可知，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)，但若待排序列为“正序”时，其时间复杂度可提高至O(n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。  
希尔排序的基本思想是：先将待排序表分割成若干形如L[i，i+d，i+2d，···，i+kd]的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。  
希尔排序的过程如下：先取一个小于n的步长d<sub>1</sub>，把表中的全部记录分为d<sub>1</sub>组，所有距离为d<sub>1</sub>的倍数的记录放在同一组，在各组内进行直接插入排序；然后取第二个步长d<sub>2</sub> < d<sub>1</sub>，重复上述过程，直到所取到的d<sub>t</sub> = 1，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是d<sub>1</sub> = n/2，d<sub>i+1</sub> = ⎣d<sub>i</sub> / 2⎦，并且最后一个增量等于1。  
希尔排序算法的代码如下：  
```C
void ShellSort(ElemType A[], int n)
{
    for(dk = n/2; dk >= 1; dk = dk / 2)
    {
        for(i = dk+1; i <= n; ++i)
        {
            if(A[i] < A[i - dk])
            {
                A[0] = A[i];// 
                for(j = i-dk; j > 0&&A[0] < A[j]; j-=dk)
                {
                    A[j+dk] = A[j];// 记录后移
                }
                A[j+dk] = A[0];
            }
        }
    }
}
```  
性能分析：  
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。  
时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，当n在某个特定范围时，希尔排序的时间复杂度约为O(n<sup>1/3</sup>)。在最坏情况下希尔排序的时间复杂度为O(n<sup>2</sup>)。  
稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。  
适用性：希尔排序算法仅适用于线性表为顺序存储的情况。（需要随机访问特性）  

---  
## 交换排序  
> 根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置  

基于交换的排序算法很多，以下主要介绍冒泡排序和快速排序。  
### 冒泡排序  
冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果就是把序列中的最小元素（或最大元素）放到了序列的最终位置······这样最多做n-1趟就能把所有元素排好序。  
冒泡排序的算法的代码如下：  
```C
void BubbleSort(ElemType A[], int n)
{
    for(i = 0; i < n-1; i++)
    {
        flag = false;// 表示本趟冒泡是否发生交换
        for(j = n-1; j > i; j--)
        {
            if(A[j-1] > A[j])
            {
                swap(A[j-1], A[j]);
                flag = true;// 发生交换
            }
        }
        // 每趟结束后判断本次是否发生交换，如未发生交换，说明元素已经有序  
        if(flag == false)
        {
            return ;
        }
    }
}
```  
性能分析：  
空间效率：仅使用了常数个辅助单位，因而空间复杂度为O(1)。  
时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false，从而直接跳出循环，比较次数为n-1次，移动次数为0，从而最好情况下的时间复杂度为O(n)；当初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的的比较，而且每次比较后都必须移动元素3次来交换元素位置。这种情况下：  
比较次数 = n(n-1)/2  
移动次数 = 3n(n-1)/2  
从而，最坏情况下的时间复杂度为O(n<sup>2</sup>)，其平均时间复杂度也为O(n<sup>2</sup>)。  
稳定性：由于i>j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。  
冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于或大于无须子序列中所有元素的关键字，这样每趟排序都会把一个元素放置到其最终位置上。  

### 快速排序  
快速排序的思想是基于分治法的：在待排序表L[1···n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1···k-1]和L[k+1···n]，使得L[1···k-1]中的所有元素小于pivot，L[k+1···n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直到每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。  
一趟快速排序的过程是一个交替搜索和交换的过程。  
假设划分算法已知，记为Partition()，返回的是上述的k，注意到L(k)已在最终的位置，因此可以先对表进行划分，而后对两个表调用相同的排序操作。因此可以递归地调用快速排序算法进行排序，具体的程序结构如下：  
```C
void QuickSort(ElemType A[], int low, int high)
{
    if(low < high)// 递归结束条件
    {
        int pivotpos = Partition(A, low, high);// 划分
        QuickSort(A, low, pivotpos-1);
        QuickSort(A, pivot+1, high);
    }
}
```  
快速排序算法的关键在于划分操作，同时快速排序算法的性能也主要取决于划分操作的好坏。假设每次总以当前表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，使得一趟Partition()操作后，表中的元素被枢轴一分为二。代码如下：  
```C
int Partition(ElemType A[], int low, int high)
{
    ElemType pivot = A[low];// 将当前表中第一个元素设为枢轴，对表进行划分
    while(low < high)
    {
        while(low < high && A[high] >= pivot)
        {
            --high;
        }
        // 找到一个比枢轴小的，放到low所在的位置
        A[low] = A[high];
        While(low < high && A[low] <= pivot)
        {
            ++low;
        }
        // 找到一个比枢轴大的，放到high所在的位置
        A[high] = A[low];
    }
    A[low] = pivot;// 枢轴元素存放到最终位置
    return low;// 返回存放枢轴的最终位置，用于划分子表
}
```  
性能分析：  
空间效率：由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。最好情况下为O(log<sub>2</sub>n)；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；平均情况下，栈的深度为O(log<sub>2</sub>n)。  
时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(n<sup>2</sup>)。  
又很多算法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。  
在最理想的状态下，即Partition()可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n/2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为O(nlog<sub>2</sub>n)。好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。**快速排序是所有内部排序算法中平均性能最优的排序算法。**  
稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。  
在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准）元素放到其最终的位置上。  

---  
## 选择排序  
> 每一趟（如第i趟）在后面n-i+1(i = 1,2,···,n-1)个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完  

### 简单选择排序  
假设排序表为L[1···n]，第i趟排序即从L[i···n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。  
简单选择排序算法的代码如下：  
```C
void SelectSort(ElemType A[], int n)
{
    for(i = 0; i < n-1; i++)
    {
        min = i;// 记录每趟最小元素的位置
        for(j = i+1; j < n; j++)
        {
            if(A[j] < A[min])
            {
                min = j;// 记录新的最小的元素的位置
            }
        }
        if(min != i)// 最小值位置发生变更
        {
            swap(A[i], A[min]);
        }
    }
}
```  
性能分析：  
空间效率：仅适用常数个辅助单元，故空间效率为O(1)。  
时间效率：在简单选择排序过程中，元素移动的操作次数很少，不会超过3(n-1)次（即n-1次交换操作），最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是n(n-1)/2，因此时间复杂度始终是O(n<sup>2</sup>)。  
稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会**导致第i个元素与其含有相同关键字的元素的相对位置发生改变**。因此，简单选择排序是一种不稳定的排序方法。  

### 堆排序  
堆的定义如下，n个关键字差序列L[1···n]称为堆，当且仅当该序列满足：  
① L(i) ≥ L(2i)且L(i) ≥ L(2i+1)或  
② L(i) ≤ L(2i)且L(i) ≤ L(2i+1) (1 ≤ i ≤ ⎣n/2⎦)  

可以将该一维数组视为一棵完全二叉树，满足条件①的堆称为大根堆（大顶堆），大根堆的最大元素放在根结点，且其任一非根结点的值小于等于其双亲结点值。满足条件②的堆称为小根堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。  
堆排序思想：首先将存放在L[1···n]中的n个元素建成初始堆，由于堆本身的特点（以大顶堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见堆排序需要解决两个问题：①如何将无序序列构造成初始堆 ②输出堆顶元素后，如何将剩余元素调整成新的堆。  
堆排序的关键是构造初始堆。n个结点的完全二叉树，最后一个结点是第⎣n/2⎦个结点的孩子。对第⎣n/2⎦个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字的较大者，则交换），使该子树称为堆。之后向前依次对各结点（⎣n/2⎦-1 ~ 1）为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。  
输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。  
下面是建大根堆的算法：  
```C
void BuildMaxHeap(ElemType A[], int len)
{
    for(int i = len/2; i > 0; i--)
    {
        HeadAdjust(A, i, len);
    }
}
void HeadAdjust(ElemType A[], int k, int len)
{
    // 将A[k]所在的子树调整为大根堆
    A[0] = A[k];
    for(i = 2*k; i <= len; i *= 2)
    {
        if(i < len && A[i] < A[i+1])
        {
            // 选取key较大的子结点
            i++;
        }
        if(A[0] >= A[i])
        {
            break;// 筛选结束
        }
        else
        {
            A[k] = A[i];// A[i]调整至双亲的位置
            k = i;// 修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0];// 被筛选结点的值放入最终位置
}
```  
调整的时间与树高有关，为O(h)。在建含n个元素的堆时，关键字的比较次数不超过4n，时间复杂度为O(n)，这说明可以在线性时间内将一个无序数组建成一个堆。  
下面是堆排序算法：  
```C
void HeapSort(ElemType A[], int len)
{
    BuildMaxHeap(A, len);
    for(i = len; i > 1; i--)
    {
        Swap(A[i], A[1]);// 输出堆顶元素（和堆底元素交换）
        HeadAdjust(A, 1, i-1);// 调整剩余的i-1个元素组成的堆
    }
}
```  
同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。  
堆排序适合关键字较多的情况（如n>1000）。例如，在1亿个数中选出前100个最大值？首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数即为所求。  
性能分析：  
空间效率：仅使用了常数个辅助单元，所以空间复杂度为O(1)。  
时间效率：建堆时间为O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为O(h)，故在最好、最坏和平均情况下，堆排序的时间复杂度为O(nlog<sub>2</sub>n)。  
稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序方法。 

---  
## 归并排序和基数排序  
### 归并排序  
归并排序与基于交换、选择等排序的思想不一样，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两归并，得到⎡n/2⎤个长度为2或1的有序表，继续两两归并······如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2路归并排序。  
Merge()的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[low...mid]、A[mid+1...high]存放在同一顺序表的相邻位置，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字的比较。将较小者放入A中，当数组B中有一段的下标超出其对应表长（即该段的所有元素都已复制到A中）时，将另一段中的剩余部分直接复制到A中。算法如下：  
```C
ElemType *B = (ElemType *)malloc((n+1) * sizeof(ElemType));// 辅助数组B
void Merge(ElemType A[], int low, int mid, int high)
{
    // 表A的两段[low...mid]、A[mid+1...high]各自有序，将它们合并成一个有序表
    for(int k = low; k <= high; k++)
    {
        B[k] = A[k];// 将A中所有元素复制到B中
    }
    for(i = low, j = mid+1, k = i; i <= mid && j <= high; k++)
    {
        if(B[i] < B[j])
        {
            A[k] = B[i++];
        }
        else
        {
            A[k] = B[j++];
        }
    }
    while(i <= mid)
    {
        A[k++] = B[i++];// 第一个表未检测完，复制
    }
    while(j <= high)
    {
        A[k++] = B[j++];// 第二个表未检测完，复制
    }
}
```  
一趟归并排序的操作是，调用⎡n/2h⎤次算法Merge()，将L[1...n]中前后相邻且长度为h的有序段进行两两合并，得到前后相邻、长度为2h的有序表，整个归并排序需要进行⎡log<sub>2</sub>n⎤趟。  
递归形式的2路归并排序算法是基于分治的。其过程如下： 
分解：将含有n个元素的待排序表分成各含n/2个元素的子表，采用2路归并算法对两个子表递归地进行排序。  
合并：合并两个已排序的子表得到排序结果。  
```C
void MergeSort(ElemType A[], int low, int high)
{
    if(low < high)
    {
        int mid = (low + high) / 2;// 从中间划分两个序列
        MergeSort(A, low, mid);
        MergeSort(A, mid +1, high);
        Merge(A, low, mid, high);
    }
}
```  
性能分析：  
空间效率：Merge()操作中，辅助空间刚好为n个单元，所以算法的空间复杂度为O(n)。  
时间效率：每趟归并的时间复杂度为O(n)，共需进行⎡log<sub>2</sub>n⎤趟归并，所以算法的时间复杂度为O(nlog<sub>2</sub>n)。  
稳定性：由于Merge()操作不会改变相同关键字记录的相对次序，所以2路归并排序算法是一种稳定的排序方法。

### 基数排序  
基数排序是一种很特别的排序方法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。  
假设长度为n的线性表中每个结点a<sub>j</sub>的关键字由d元组（k<sub>j</sub><sup>d-1</sup>，k<sub>j</sub><sup>d-2</sup>，···，k<sub>j</sub><sup>1</sup>，k<sub>j</sub><sup>0</sup>）组成，满足0 ≤ k<sub>j</sub><sup>i</sup> ≤ r-1(0 ≤ j ≤ n, 0 ≤ i ≤ d-1)。其中k<sub>j</sub><sup>d-1</sup>为最主位关键字，k<sub>j</sub><sup>0</sup>为最次位关键字。  
为实现多关键字排序，通常有两种方法：第一种是最高位优先法MSD法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。第二种是最低位优先LSD法，按关键字权重递减依次进行排序，最后形成一个有序序列。  
下面描述以r为基数的最低位优先基数排序的过程，在排序过程中，使用r个队列𝑸<sub>0</sub>,𝑸<sub>1</sub>,···,𝑸<sub>r-1</sub>。基数排序的过程如下：  
对i=0,1,···,d-1，依次做一次“分配”和“收集”  
分配：开始时，把𝑸<sub>0</sub>,𝑸<sub>1</sub>,···,𝑸<sub>r-1</sub>各个队列置成空队列，然后依次考察线性表中的每个结点a<sub>j</sub>(j = 0,1,···,n-1)，若a<sub>j</sub>的关键字k<sub>j</sub><sup>i</sup>=k，就把a<sub>j</sub>放入𝑸<sub>k</sub>队列中。  
收集：把𝑸<sub>0</sub>,𝑸<sub>1</sub>,···,𝑸<sub>r-1</sub>各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。  
性能分析：  
空间效率：一趟排序需要的辅助空间为r（r个队列：r个头指针和r个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为O(r)。  
时间效率：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，所以基数排序的时间复杂度为O(d(n+r))，它与序列的初始状态无关。  
稳定形：对于基数排序算法而言，很重要的一点就是按位排序时必须是稳定的。因此，这也保证了基数排序的稳定性。  

---  
## 各种内部排序算法的比较及应用  

### 内部排序算法的比较  
从时间复杂度看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为O(n<sup>2</sup>)，且实现过程也较简单，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到O(n)，而简单选择排序则与是系列的初始状态无关。希尔排序作为插入排序的扩展，对较大规模的排序都可以达到很高的效率，但目前为得出其精确的渐进时间。堆排序利用了一种称为堆的数据结构，可在线性时间内完成建堆，且在O(nlog<sub>2</sub>n)内完成排序过程。快速排序基于分治的思想，虽然最坏情况下时间会达到O(n<sup>2</sup>)，但快速排序平均性能可以达到O(nlog<sub>2</sub>n)，在实际应用中常常优于其他排序算法。归并排序同样基于分治思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为O(nlog<sub>2</sub>n)。  
从空间复杂度看：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要借助常数个辅助空间。快速排序在空间上只使用一个小小的辅助栈，用于实现递归，平均情况下大小为O(log<sub>2</sub>n)，当然在最坏情况下可能会增长到O(n)。2路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为O(n)，虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。  
从稳定性看：插入排序、冒泡排序、归并排序和基数排序都是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。  

|算法种类|最好情况|平均情况|最坏情况|空间复杂度|是否稳定|  
|:---:|:---:|:---:|:---:|:---:|:---:|  
|直接插入排序|O(n)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|是|  
|冒泡排序|O(n)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|是|  
|简单选择排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|否|  
|希尔排序|  |  |  |O(1)|否|  
|快速排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(n<sup>2</sub>)|O(log<sub>2</sub>n)|否|  
|堆排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(1)|否|  
|2路归并排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(n)|是|  
|基数排序|O(d(n+r))|O(d(n+r))|O(d(n+r))|O(r)|是|  

其中希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。  

### 内部排序算法的应用  
通常情况，对排序算法的比较和应用应考虑以下情况：  
+ 选取排序方法需要考虑的因素  
  - 待排序的元素的数目n  
  - 元素本身信息量的大小  
  - 关键字的结构及其分布情况  
  - 稳定性的要求  
  - 语言工具的条件，存储结构及辅存空间的大小等  

+ 排序算法小结  
  - 若n较小，则采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。  
  - 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。  
  - 若n较大，则应采用时间复杂度为O(nlog<sub>2</sub>n)的排序方法：快速排序、堆排序或归并排序。快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。若要求排序稳定且时间复杂度为O(nlog<sub>2</sub>n)，则可选用归并排序。通常将它和直接插入结合在一起使用：先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。  
  - 在基于比较的排序方法中，每次比较两个关键字的大小后，仅出现两种可能的转移，因此可以利用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要O(nlog<sub>2</sub>n)的时间。  
  - 若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。  
  - 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。  