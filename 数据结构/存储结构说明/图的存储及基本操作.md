## 图的存储及基本操作  
图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于欲求解的问题。  
### 邻接矩阵法  
所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。  
结点数为n的图G = (V, E)的邻接矩阵**A**是n×n的。将G的顶点编号为v<sub>1</sub>，v<sub>2</sub>，···，v<sub>n</sub>。若(v<sub>i</sub>,v<sub>j</sub>) ∈ E，则A[i][j] = 1，否则A[i][j] = 0。  
对于带权图而言，若顶点v<sub>i</sub>和v<sub>j</sub>之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点v<sub>i</sub>和v<sub>j</sub>不相连，则用∞来代表这两个顶点之间不存在边。  
图的邻接矩阵存储结构定义如下：  
```C
#define MaxVertexNum 100// 顶点数目的最大值
typedef char VertexType;// 顶点的数据类型
typedef int EdgeType;// 带权图中边上权值的数据类型
typedef struct
{
    VertexType Vex[MaxVertexNum];// 顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];// 邻接矩阵
    int vexnum, arcnum;// 图的当前顶点数和弧数
}MGraph;
```
Notes:  
+ 在简单应用中，可直接用二维数组作为图的邻接矩阵，即顶点信息等均可忽略。  
+ 当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。  
+ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。  
+ 邻接矩阵表示法的空间复杂度为O(n<sup>2</sup>)，其中n为图的顶点数|V|。  

图的邻接矩阵存储表示法具有以下特点：  
+ 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。  
+ 对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度TD(v<sub>i</sub>)。  
+ 对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度OD(v<sub>i</sub>)（或入度ID(v<sub>i</sub>)）。  
+ 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。  
+ 稠密图适合用邻接矩阵的存储表示。  
+ 设图G的邻接矩阵为A，A<sup>n</sup>的元素A<sup>n</sup>[i][j]等于由顶点i到顶点j的长度为n的路径的数目。  

### 邻接表法  
当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。  
所谓邻接表，是指对图G中的每个顶点v<sub>i</sub>建立一个单链表，第i个单链表中的结点表示依附于顶点v<sub>i</sub>的边（对于有向图则是以顶点v<sub>i</sub>为尾的弧），这个单链表就成为顶点v<sub>i</sub>的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。  

定点表结点由顶点域和指向第一条邻接边的指针构成：

|顶点域|边表头指针|  
|---|---|  
|data|firstarc|  

边表（邻接表）结点由邻接点域和指向下一条邻接边的指针域构成：  

|邻接点域|指针域|  
|---|---|  
|adjvex|nextarc|  

图的邻接表存储结构定义如下：  
```C
#define MaxVertexNum 100;// 图中结点数目的最大值
typedef struct ArcNode// 边表结点
{
    int adjvex;// 该弧所指向的顶点的位置
    struct ArcNode *next;// 指向下一条弧的指针
    // InfoType info;// 网的边权值
}ArcNode;
typedef struct VNode// 顶点表结点
{
    VertexType data;// 顶点信息
    ArcNode *first;// 指向第一条依附该顶点的弧的指针
}VNode, AdjList[MaxVertexNum];
typedef struct
{
    AdjList vertices;// 邻接表
    int vexnum, arcnum;// 图的顶点数和弧数
}ALGraph;
```  
图的邻接表存储方法具有以下特点：  
+ 若G为无向图，则所需的空间为O(|V|+2|E|)；若G为有向图，则所需的存储空间为O(|V|+|E|)。  
+ 对于稀疏图，采用邻接表表示将极大地节省存储空间。  
+ 在邻接表中，给定一个顶点，很容易地找出它的所有临边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若是要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立即查到，而在邻接矩阵中则需要在相应结点对应的边表中查找另一结点，效率较低。  
+ 在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。因此，可以采用逆邻接表的存储方式来加速求解给定结点的入度。  
+ 图的邻接表并不唯一，因为在每个结点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。  

### 十字链表  
十字链表是**有向图**的一种链接存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。结点的结构如下：  
弧结点中有5个域：尾域tailvex和头域headvex分别指示弧尾和弧头这两个项点在图中的位置；链域hlink指向弧头相同的下一条弧；链域tlink指向弧尾相同的下一条弧；info域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。  

|tailvex|headvex|hlink|tlink|info|  
|---|---|---|---|---|  

顶点结点中有3个域：data域存放顶点相关的数据信息，如顶点名称；firstin和firstout两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。  

|data|firstin|firstout|  
|---|---|---|  

在十字链表中，既容易找到v<sub>i</sub>为尾的弧，又容易找到v<sub>i</sub>为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示确定一个图。  

### 邻接多重表  
邻接多重表是**无向图**的另一个链式存储结构。  
在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。  
与十字链表类似，在邻接多重表中，每条边用一个节点表示，其结构如下所示：  

|mark|ivex|ilink|jvex|jlink|info|  
|---|---|---|---|---|---|  

其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。  
每个顶点也用一个结点表示，它由如下所示的两个域组成：  

|data|fisrtedge|  
|---|---|  

其中，data域存储该顶点的相关信息，firstedge域指示第一条依附于该顶点的边。  
在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于同一条边在邻接表中用两个结点表示，而在邻接表中只有一个结点。  

### 图的基本操作  
图的基本操作是独立于图的存储结构的。而对不同的存储方式，操作算法的具体实现会有不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。  
图的基本操作主要包括  
```C
Adjacent(G, x, y);// 判断图G是否存在有向边<x,y>或无向边(x,y)
Neighbors(G, x);// 列出图G中与结点x邻接的边
InsertVertex(G, x);// 在图G中插入顶点x
DeleteVertex(G, x);// 从图G中删除顶点x
AddEdge(G, x, y);// 若有向边<x,y>或无向边(x,y)不存在，则向图G中添加该边
RemoveEdge(G, x, y);// 若有向边<x,y>或无向边(x,y)存在，则从图G中删除该边
FirstNeighbor(G, x);// 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1
NextNeighbor(G, x, y);// 假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1
Get_edge_value(G, x, y);// 获取图G中有向边<x,y>或无向边(x,y)对应的权值
Set_edge_value(G, x, y, v);// 设置图G中有向边<x,y>或无向边(x,y)对应的权值为v
```