## 图的应用  
### 最小生成树  
一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。  
对于一个带权连通无向图G = (V, E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设𝕽为G的所有生成树的集合，若T为𝕽中边的权值之和最小的那棵生成树，则T称为G的最小生成树(Minimum-Spanning Tree,MST)。  
最小生成树具有如下性质：  
+ 最小生成树不是唯一的，即最小二叉树的树形不唯一，𝕽中可能有多个最小生成树。当图G中的各边权值互不相等时，G的最小生成树是唯一的；若无向连通图G的边数比顶点树少1，即G本身是一棵树时，则G的最小生成树就是它本身。  
+ 最小生成树的边的权值之和总是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和是唯一的，而且是最小的。  
+ 最小生成树的边数为顶点数减1  

构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质；假设G = (V, E)是一个带权连通无向图，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值的边，其中u∊U，v∊V-U，则必存在一棵包含边(u, v)的最小生成树。  
基于该性质的最小生成树算法主要有Prim算法和kruskal算法，它们都基于贪心算法的策略。  
通用最小生成树算法：  
```C
GENERIC_MST(G)
{
    T = NULL;
    while T 未形成一棵生成树
        do 找到一条最小代价边(u, v)并且加入T后不会产生回路
            T = T ⋃ (u, v);
}
```
#### Prim算法  
Prim算法构造最小生成树的过程：初始时从图中任取一顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入T，得到的就是最小生成树。此时T中必然有n-1条边。  
Prim算法的步骤如下：  
假设G = (V, E)是连通图，其最小生成树T = (U, E<sub>T</sub>)，E<sub>T</sub>是最小生成树中边的集合。  
+ 初始化：向空树T = (U, E<sub>T</sub>)中添加图G = (V, E)的任一顶点u<sub>0</sub>，使U = {u<sub>0</sub>}，E<sub>T</sub> = ∅。  
+ 循环（重复下列操作直至U == V）：从图中选择满足{(u, v)|u∊U，v∊V-U}切具有最小权值的边(u, v)，加入树T，置U = U ⋃ {v}，E<sub>T</sub> = E<sub>T</sub> ⋃ {(u, v)}。  

Prim算法的简单实现如下：  
```C
void Prim(G, T)
{
    T = ∅;// 初始化空树
    U = {w};// 添加任一顶点w
    while((V - U) != ∅)// 树中不含所有结点
    {
        设(u, v)是使u∊U，v∊V-U，且权值最小的边
        T = T ⋃ {(u, v)};
        U = U ⋃ {v};
    }
}
```  
Prim算法的时间复杂度为O(|V|<sup>2</sup>)，不依赖于|E|，因此它适用于求解边稠密的图的最小生成树。  

#### Kruskal算法  
与Prim算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合适的边构造生成树的方法。  
Kruskal算法构造最小生成树的过程：初始时只有n个顶点而无边的非连通图T = {V, {}}，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在不同的连通分量上，则将此边加入T，否则舍弃此边而选择下一条权值最小的边。以此类推，直至T中所有丁点都在同一个连通分量上。  
Kruskal算法的步骤如下：  
假设G = (V, E)是连通图，其最小生成树T = (U, E<sub>T</sub>)。  
+ 初始化：U = V，E<sub>T</sub> = ∅。即每个顶点构成一棵独立的树，T此时是一个仅含|V|个顶点的森林。  
+ 循环（重复下列操作直至T是一棵树）：按G的边的权值递增顺序依次从E - E<sub>T</sub>中选择一条边，若这条边加入T后不构成回路，则将其加入E<sub>T</sub>，否则舍弃，直到E<sub>T</sub>中含有n-1条边。  

Kruskal算法的简单实现如下：  
```C
void Kruskal(V, T)
{
    T = V; // 初始化树T，仅含顶点
    numS = n;// 连通分量数
    while(numS > 1)
    {
        从E中取出权值最小的边(v, u);
        if(v和u属于T中不同的连通分量)
        {
            T = T ⋃ {(v, u)};
            numS--;
        }
    }
}
```  
根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。  
通常在Kruskal算法中，采用堆来存放边的集合，因此每次选择权值最小的边只需要O(log|E|)的时间。此外，由于生成树T中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为O(|E|log|E|)。因此，Kruskal算法适合于边稀疏而顶点较多的图。  

### 最短路径  
广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点v<sub>i</sub>到图中其余任意一个顶点v<sub>j</sub>的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。  
求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra算法求解；二是求每对顶点间的最短路径，可通过Floyd算法来求解。  
#### Dijkstra算法求单源最短路径问题  
Dijkstra算法设置一个集合S记录已求得的最短路径的顶点，初始时把源点v<sub>0</sub>放入S，集合S每并入一个新顶点v<sub>i</sub>，都要修改源点v<sub>0</sub>到集合V-S中顶点当前的最短路径的长度值。  
在构造的过程中还设置了两个辅助数组：  
+ dist[]：记录从源点v<sub>0</sub>到其他各顶点当前的最短路径长度，它的初态为：若从v<sub>0</sub>到v<sub>i</sub>有弧，则dist[i]为弧上的权值；否则置dist[i]为∞。  
+ path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。在算法结束时，可根据其值追溯到源点v<sub>0</sub>到顶点v<sub>i</sub>的最短路径。  

假设从顶点0出发，即v<sub>0</sub>=0，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边<i, j>的权值，若不存在有向边<i, j>，则arcs[i][j]为∞。  
Dijkstra算法的步骤如下（不考虑对path[]的操作）：  
+ 初始化：集合S初始为{0}，dist[]的初始值dist[i] = arcs[0][i]，i = 1, 2,···,n-1。  
+ 从顶点集合V-S中选出v<sub>j</sub>，满足dist[j] = Min{dist[i] | v<sub>i</sub>∊V-S}，v<sub>j</sub>就是当前求得的一条从v<sub>0</sub>出发的最短路径的终点，令S = S ⋃ {j}。  
+ 修改从v<sub>0</sub>出发到集合V-S上任一顶点v<sub>k</sub>可达的最短路径长度：若dist[j]+arcs[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs[j][k]<dist[k]。  
+ 重复第二步~第三步操作共n-1次，直到所有顶点都包含在S中。  

显然，Dijkstra算法也是基于贪心策略的。  
使用邻接矩阵表示时，时间复杂度为O(|V|<sup>2</sup>)。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，时间复杂度仍为O(|V|<sup>2</sup>)。  
人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为O(|V|<sup>2</sup>)。  
**边上带有负权值时，Dijkstra算法并不适用**。若允许边上带有负权值，则在与S（已求得最短路径的顶点集，归入S内的结点的最短路径不再变更）内某点（记为a）以负边相连的点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于a原先确定的最短路径长度，而此时a在Dijkstra算法下是无法更新的。  

#### Floyd算法求各顶点之间最短路径问题  
求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对任意两个顶点v<sub>i</sub>≠v<sub>j</sub>，要求求出v<sub>i</sub>和v<sub>j</sub>之间的最短路径和最短路径长度。  
Floyd算法的基本思想是：递推产生一个n阶方阵序列A<sup>(-1)</sup>，A<sup>(0)</sup>，···，A<sup>(k)</sup>，···，A<sup>(n-1)</sup>其中A<sup>(k)</sup>[i][j]表示从顶点v<sub>i</sub>到顶点v<sub>j</sub>的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点v<sub>i</sub>和v<sub>j</sub>，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0,1,···,n-1)作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法描述如下：  
定义一个n阶方阵序列A<sup>(-1)</sup>，A<sup>(0)</sup>，···，A<sup>(k)</sup>，···，A<sup>(n-1)</sup>，其中，  
A<sup>(-1)</sup> = arcs[i][j]  
A<sup>(k)</sup> = Min{A<sup>(k-1)</sup>[i][j], A<sup>(k-1)</sup>[i][k] + A<sup>(k-1)</sup>[k][j]}， k = 0,1,···,n-1  
式中，A<sup>(0)</sup>[i][j]是从顶点v<sub>i</sub>到顶点v<sub>j</sub>、中间顶点是v<sub>0</sub>的最短路径的长度，A<sup>(k)</sup>[i][j]是从顶点v<sub>i</sub>到顶点v<sub>j</sub>、中间顶点的序号不大于k的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从v<sub>i</sub>到v<sub>j</sub>的最短路径上就多考虑了一个顶点；经过n次迭代后，所得到的A<sup>(n-1)</sup>[i][j]就是v<sub>i</sub>到v<sub>j</sub>的最短路径长度，即方阵A<sup>(n-1)</sup>中保存了任意一对顶点之间的最短路径长度。  
Floyd算法的时间复杂度为O(|V|<sup>3</sup>)。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。  
Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。  
也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均为非负时，运行一次Dijkstra算法，其时间复杂度为O(|V|<sup>2</sup>)·|V| = O(|V|<sup>3</sup>)。  

### 有向无环图描述表达式  
有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。  
有向无环图是描述含有公共子式的表达式的有效工具。利用有向无环图可实现相同子式的共享，从而节省存储空间。  

### 拓扑排序  
AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边<V<sub>i</sub>, V<sub>j</sub>>表示活动V<sub>i</sub>必须先于活动V<sub>j</sub>进行的这样一种关系，则将这种有向图称为*顶点表示活动的网络*，称为AOV网。在AOV网中，活动V<sub>i</sub>是活动V<sub>j</sub>的直接前驱，活动V<sub>j</sub>是活动V<sub>i</sub>的直接后继，这种前驱和后继关系具有传递性，且任何活动V<sub>i</sub>不能以它自己作为自己的前驱或后继。  
拓扑排序：在图论中，有一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：  
+ 每个顶点出现且只出现一次。  
+ 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。  

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。每个AOV网都有一个或多多个拓扑排序序列。  
对一个AOV网进行拓扑排序的算法很多，下面介绍比较常用的一种方法的步骤：  
+ 从AOV网中选择一个没有前驱的结点顶点并输出。  
+ 从网中删除该顶点和所有以它为起点的有向边。  
+ 重复上述两步直到当前的AOV网为空或当前网中不存在无前驱的结点为止。后一种情况说明有向图中必然存在环。  

拓扑排序算法的实现如下：  
```C
bool TopologicalSort(Graph G)
{
    InitStack(S);// 初始化栈，存储入度为0的结点  
    for(int i = 0; i < G.vexnum; i++)
    {
        if(indegree[i] == 0)
        {
            Push(S, i);
        }
    }
    int count = 0;// 记录当前已经输出的结点数
    while(!StackEmpty(S))
    {
        Pop(S, i);
        print[count++] = i;// 输出顶点i
        for(p = G.vertices[i].firstarc; p; p = p -> nextarc)
        {
            // 将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S
            v = p -> adjvex;
            if(!(--indegree[v]))
            {
                // 入度减为0，入栈
                Push(S, v);// 入度为0，则入栈
            }
        }
    }// while
    if(count < G.vexnum)
    {
        return false;// 排序失败，有向图中有回路
    }
    else
    {
        return true;// 拓扑排序成功
    }
}
```  
由于输出每个顶点的同时还要删除以它为起点的边，故拓扑排序的时间复杂度为O(|V|+|E|)。  
对一个AOV网，如果采用下列步骤进行排序，则称之为逆拓扑排序：  
+ 从AOV网中选择一个没有后继（出度为0）的顶点并输出。  
+ 从网中删除该结点和所有以它为终点的有向边。  
+ 重复上述两步直到当前的AOV网为空。  

用拓扑排序算法处理AOV网时，应注意以下问题：  
+ 入读为零的顶点，即没有前驱活动的或前驱活动都已完成的顶点，工程可以从这个顶点所代表的活动开始或继续。  
+ 若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排列在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。  
+ 由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。  

