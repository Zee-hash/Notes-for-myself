# 树和二叉树的应用  
---  
## 二叉排序树BST  
### 二叉排序树的定义  
二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：  
+ 若左子树非空，则左子树上所有结点的值均小于根结点的值  
+ 若右子树非空，则右子树上所有结点的值均大于根结点的值  
+ 左、右子树也分别是一棵排序二叉树  

根据二叉排序树的定义，左子树结点值<根结点值<右子树结点值，所以对二叉树进行中序遍历，可以得到一个递增的有序序列。  
### 二叉排序树的查找  
二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。  
二叉排序树的非递归查找算法：  
```C
BSTree *BST_Search(BiTree T, ElemType key)
{
    while(T != NULL && key != T->data)// 若树空或等于根结点值，则结束循环
    {
        if(key < T->data)
        {
            T = T -> lchild;// 从左子树上继续查找
        }
        else
        {
            T = T -> rchild;// 从右子树上继续查找
        }
    }
    return T;
}
```  
### 二叉排序树的插入  
二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点再进行插入的。  
插入结点的过程如下：若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树，插入的结点一定是个新添加的叶节点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。  
二叉排序树插入操作的算法描述如下：  
```C
int BST_Insert(BiTree &T, KeyType k)
{
    if(T == NULL)// 原树为空，新插入的记录为根结点
    {
        T = (BiTree)malloc(sizeof(BSTNode));
        T -> key = k;
        T -> lchild = NULL;
        T -> rchild = NULL;
        return 1;// 插入成功
    }
    else if(k == T -> key)// 树中存在相同关键字的结点，插入失败
    {
        return 0;
    }
    else if(k < T -> key)// 插入到T的左子树
    {
        return BST_Insert(T->lchild, k);
    }
    else// 插入到T的右子树
    {
        return BST_Insert(T->rchild, k);
    }
}
```  
### 二叉树的构造  
从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。  
构造二叉排序树的算法描述如下：  
```C
void Create_BST(BiTree &T, KeyType str[], int n)
{
    T = NULL;
    int i = 0;
    while(i < n)// 依次将每个关键字插入到二叉排序树中
    {
        BST_Insert(T, str[i]);
        i++;
    }
}
```  
### 二叉排序树的删除  
从二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：  
+ 若被删除的结点z是叶结点，则直接删除，不会破坏二叉排序树的性质  
+ 若结点z只有一棵左子树或右子树，则让z的子树称为z父结点的子树，替代z的位置。  
+ 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删除这个直接后继（或直接前驱），这样就转换成了第一种或第二种情况。  

### 二叉排序树的查找效率分析  
二叉排序树的查找效率，主要取决于树的高度。若二叉排序树的左、右子树的高度之差的绝对值不超过1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为O(log<sub>2</sub>n)。若二叉排序树是一个只有右（左）孩子的单支树，则其平均查找长度为O(n)。  
在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变差，树的高度也增加为元素个数n。  
从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树。  
就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，平均维护时间为O(log<sub>2</sub>n)。二分查找的对象是有序表，若有插入和删除结点的操作，所花的代价是O(n)。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表时，则应选择二叉排序树作为其逻辑结构。  

---  
## 平衡二叉树  
### 平衡二叉树的定义  
为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树，简称平衡树。定义结点左子树和右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只能是-1，0，1。  
因此，平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：  
+ 左子树和右子树都是平衡二叉树  
+ 左子树和右子树的高度差的绝对值不超过1  

### 平衡二叉树的插入  
二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到**插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A**，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。  
平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新节点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：  
+ LL平衡旋转（右单旋转）
  由于在结点A的左子树(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右旋转的操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左孩子。  
+ RR平衡旋转（左单旋转）
  由于在结点A的右孩子(R)的右子树(R)上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的右孩子B向左上旋转替代A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。  
+ LR平衡旋转（先左后右双旋转）
  由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置。  
+ RL平衡旋转（先右后左双旋转）
  由于在A的右孩子(R)的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。  

### 平衡二叉树的查找  
在平衡二叉树上进行查找的过程和二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。假设以n<sub>h</sub>表示深度为h的平衡树中含有的最少结点数。显然，有n<sub>0</sub>=0，n<sub>1</sub>=1，n<sub>2</sub>=2，并且有**n<sub>h</sub>=n<sub>h-1</sub>+n<sub>h-2</sub>+1**。可以证明，含有n个结点的平衡二叉树的最大深度为O(log<sub>2</sub>n)，因此平衡二叉树的平均查找长度为O(log<sub>2</sub>n)。  

---  
## 哈夫曼树和哈夫曼编码  
### 哈夫曼树的定义  
在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到任意结点的路径长度（经过的边数）与该节点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度，即为WPL。  
WPL = *w<sub>1</sub>l<sub>1</sub>+w<sub>2</sub>l<sub>2</sub>+···+w<sub>n</sub>l<sub>n</sub>*  
式中，w<sub>i</sub>是第i个叶结点所带的权值，l<sub>i</sub>是该叶结点到根结点的路径长度。  
在含有n个带权叶结点的二叉树中，其中WPL最小的二叉树称为哈夫曼树，也称最优二叉树。  
### 哈夫曼树的构造  
给定n个权值分别为w<sub>1</sub>，w<sub>2</sub>，···，w<sub>n</sub>的结点，构造哈夫曼树的算法描述如下：  
+ 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F  
+ 构造一个新结点，从F中选择两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和  
+ 从F中删除刚才选出的两棵树，同时将新得到的树加入F中  
+ 重复第二、三步，直至F中只剩下一棵树为止  

从上述构造过程中可以看出哈夫曼树具有如下特点：  
+ 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大  
+ 构造过程中共新建了n-1个结点（双分支结点），因此哈夫曼树的结点总数为2n-1  
+ 每次构造都选择2棵树作为新结点的孩子，因此哈弗曼树中不存在度为1的结点。  

### 哈夫曼编码  
在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。  
若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。  
由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”。  
由于左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如果有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然是相同且最优的。  